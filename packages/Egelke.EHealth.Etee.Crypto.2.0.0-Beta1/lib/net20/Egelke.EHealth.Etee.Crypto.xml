<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Egelke.EHealth.Etee.Crypto</name>
    </assembly>
    <members>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.CertificateSecurityInformation">
            <summary>
            Security information of certificates.
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1">
            <summary>
            Base class for security violation data.
            </summary>
            <typeparam name="TViolation">The enum of possible violations</typeparam>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.ToString">
            <summary>
            Detailed printout of the object.
            </summary>
            <returns>String representation of the instance</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.ValidationStatus">
            <summary>
            Indicates if the content can be trusted.
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.TrustStatus">
            <summary>
            Indicates if the sender can be confirmed.
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.CertificateSecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.CertificateSecurityInformation.Certificate">
            <summary>
            The certificate on which the checks where executed.
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.CertificateSecurityInformation.IssuerInfo">
            <summary>
            The security information of the issuer.
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.CertificateSecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation"/>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.IAnonymousDataUnsealer">
            <summary>
            Interface to read messages that are protected according to the eHealth End-To-End encryption.
            </summary>
            <remarks>
            <para>
            When you have a protected message you want to read only unknown (non-addressed) messages, 
            you should use an instance that implements this
            interface.
            </para>
            <para>
            The <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/> class should be used to get an instance that implements
            this interface.
            </para>
            <para>
            This interface assumes you have access to the required artififacts: a KGSS generated key.  
            Retreiving the artifact isn't part of this assembly, but this
            assembly is bundleled with source code that show how it can be done.
            </para>
            <para>
            The library does not occupy itself with the message itself.  It is always treated as an
            array of bytes.  If the message is text, xml or any other format, you and the receiving 
            parties are responsible for the correct encoding/decoding.  The library is also not 
            responsible of the transport of the messages.
            </para>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.SecretKey"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult"/>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.IAnonymousDataUnsealer.Unseal(System.IO.Stream,Siemens.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Unseals a protected message of which you have the secret (but shared) key.
            </summary>
            <para>
            This method takes a sealed/protected message in the form of a stream and unseals it so it
            can be read.  It uses the key provided in the <paramref name="key"/> parameter for decryption,
            even if the instance contains a personal private key.  In other words, the secret key
            take precendence over the private key.
            </para>
            <param name="sealedData">The protected message that must be unsealed</param>
            <param name="key">The secret (but shared) key retrieved from the KGSS</param>
            <returns>
            <list type="bullet">
            <item>
            <description>The clear message as a temporary file stream that is deleted when the stream is closed</description>
            </item>
            <item>
            <description>The sender information, if known</description>
            </item>
            <item>
            <description>The detailed security information</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentNullException">When sealedData and/or key is null</exception>
            <exception cref="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when secret key does't correspond with message</exception>
            <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
            <example>
            Unseal an unaddressed message
            <code lang="cs">
            //Create a IAnonymousDataSealer instance
            IAnonymousDataSealer unsealer = DataUnsealerFactory.Create();
            
            //Read the key id send by the sender
            byte[] keyId = Utils.ReadFully("protectedForGroup.kid");
            //Get the key from the KGSS
            byte[] key = GetKeyFromKGSS(keyId);
            //Create a secrte key object
            SecretKey skey = new SecretKey(keyId, key);
            
            UnsealResult result;
            FileStream file = new FileStream("protectedForGroup.msg", FileMode.Open);
            using(file)
            {
                result = unsealer.Unseal(file, skey);
            }
            //Check if the content is in order
            if (result.SecurityInformation.ValidationStatus != ValidationStatus.Valid) throw new Exception(result.SecurityInformation.ToString());
            //Check if sender and receiver used valid and up to spec certificates
            if (result.SecurityInformation.TrustStatus != TrustStatus.Full) throw new Exception(result.SecurityInformation.ToString());
            //Check if the sender is allowed to send a message (application specific)
            VerifySender(result.Sender);
            //Use the message (application specific)
            ImportMessage(result.UnsealedData);
            </code>
            <code lang="vbnet">
            'Create a IAnonymousDataSealer instance
            Dim unsealer As IAnonymousDataUnsealer = DataUnsealerFactory.Create()
            
            'Read the key id send by the sender
            Dim keyId As Byte() = Utils.ReadFully("protectedForGroup.kid")
            'Get the key from the KGSS
            Dim key As Byte() = GetKeyFromKGSS(keyId)
            'Create a secrte key object
            Dim skey As New SecretKey(keyId, key)
            
            Dim result As UnsealResult
            Dim file As New FileStream("protectedForGroup.msg", FileMode.Open)
            Using file
                result = unsealer.Unseal(file, skey)
            End Using
            'Check if the content is in order
            If result.SecurityInformation.ValidationStatus &lt;&gt; ValidationStatus.Valid Then
                Throw New Exception(result.SecurityInformation.ToString())
            End If
            'Check if sender and receiver used valid and up to spec certificates
            If result.SecurityInformation.TrustStatus &lt;&gt; TrustStatus.Full Then
                Throw New Exception(result.SecurityInformation.ToString())
            End If
            'Check if the sender is allowed to send a message (application specific)
            VerifySender(result.Sender)
            'Use the message (application specific)
            ImportMessage(result.UnsealedData)
            </code>
            </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.IAnonymousDataUnsealer.Unseal(System.Byte[],Siemens.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Unseals a protected in memory message of which you have the secret (but shared) key.
            </summary>
            <para>
            This method takes a sealed/protected message in the form of a byte array and unseals it so it
            can be read.  It uses the key provided in the <paramref name="key"/> parameter for decryption,
            even if the instance contains a personal private key.  In other words, the secret key
            take precendence over the private key.
            </para>
            <param name="sealedData">The protected message that must be unsealed</param>
            <param name="key">The secret (but shared) key retrieved from the KGSS</param>
            <returns>
            <list type="bullet">
            <item>
            <description>The clear message as an in memory stream</description>
            </item>
            <item>
            <description>The sender information, if known</description>
            </item>
            <item>
            <description>The detailed security information</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentNullException">When sealedData and/or key is null</exception>
            <exception cref="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when secret key does't correspond with message</exception>
            <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory">
            <summary>
            <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer"/> factory class.
            </summary>
            <remarks>
            This class should be used to get an instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer"/>
            class.  This class is static, with only two static method. 
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory.Create">
            <summary>
            Creates an unaddressed-only instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.IAnonymousDataUnsealer"/> inferface.
            </summary>
            <remarks>
            <para>
            Creates a generic instance for receiving, it can be used for any receiver but only for unaddressed messages.  These
            instances can't be used to read addressed messages, for this you must use the <see cref="M:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory.Create(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2)"/>
            method.
            The instances aren't thread safe, so you also need multiple instance or a locking mechanism if you have multiple
            threads.
            </para>
            </remarks>
            <returns>Instance of the IAnonymousDataUnsealer that can be used to open unaddressed messages only</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory.Create(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Creates a all purpose instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer"/> inferface.
            </summary>
            <remarks>
            <para>
            Creates an instance specific for one receiving party this can be is a person, company, hospital or any other entity.
            This instance is specific for a reciever, so if your program supports multiple receiver it will need multiple instance.
            The instances aren't thread safe, so you also need multiple instance or a locking mechanism if you have multiple
            threads.
            </para>
            <para>
            Each instances has an decryption certficiate with private key and authentication certifcate associated with it.
            These are normaly issued by eHealth, but any 
            <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2"/> will do as long as it is compliant with the eHealth End-To-End Encyption standards.
            If using a non eHealth authentication certificate, make sure it is compliant and trusted by the recieving parties.
            </para>
            <para>
            The decryption certificate must have a <strong>exportable</strong> private key assosiated with it.  Decryption will fail
            if you use a non-exportable key.  When using a certificate from the windows certificate store, you must make sure
            the pkcs#12 file was imported with the "export"-flag checked.  When loading the Certificate2 instance directly from a pkcs#12 file
            you must mark the private key as exportable as follows:
            </para>
            </remarks>
            <example>
            Load an pkcs#12 file with exportable private key
            <code lang="cs">
            X509Certificate2 enc = new X509Certificate2("myEncStore.p12", "xxx", X509KeyStorageFlags.Exportable);
            </code>
            <code lang="vbnet">
            Dim enc As New X509Certificate2("myEncStore.p12", "xxx", X509KeyStorageFlags.Exportable)
            </code>
            </example>
            <param name="enc">The (eHealth) certificate to use for decypting the protected messages, it must have an <strong>exportable</strong> private key</param>
            <param name="auth">The (eHealth) certificate that was used to create the encryption certificate</param>
            <returns>Instance of the IDataUnsealer that can be used to open both address and non-addressed messages</returns>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation">
            <summary>
            Security information of Encryption Tokens.
            </summary>
            <remarks>
            <para>
            Encryption Tokens or ETKs are kept in the ETK-depot and can be retreived freely.
            </para>
            <para>
            The ValidationStatus applies on the token, since in this case it is content.  The TrustStatus
            applies on the eHealth signature of the cms-message.
            </para>
            <para>
            For a detailed but still comprehensible representation of the instance,
            use the ToString method.  In general there is quite
            a lot of information, so a (tab aware) text viewer is advised.
            </para>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature">
            <summary>
            The verification information of the signature that was placed by the ETK-Depot.
            </summary>
            <value>
            The ETK is a signed message, normaly signed by eHealth.  The result of the
            signature validation can be found here.
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.TokenInformation">
            <summary>
            The verification information of the encryption token.
            </summary>
            <value>
            <para>
            The ETK contains 2 certficates of which only one party (person, organisation, ...)
            has the private keys.  The authentication certificate can be used for signing only,
            the encryption certificate for encryption only.  The encryption certificate is
            "issued" (although not officialy) by the authentication certificate.
            </para>
            <para>
            The property provides you information, including validation, about the encryption certificate
            and its issuer (the authentication certificate).
            </para>
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Sender">
            <summary>
            The certificate of the party that created the ETK.
            </summary>
            <value>
            <para>
            The application is supposed to verify that the sender is actualy
            allowed to send this type of messages, the libray only validate
            that the sender information can be used or not.  The rules for validation
            is outside the scope of this project, as is the definition of the list
            of allowed senders.
            </para>
            <para>
            The same information can be retrieved from the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature"/> property.
            </para>
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation"/>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer">
            <summary>
            Interface to read messages that are protected according to the eHealth End-To-End encryption.
            </summary>
            <remarks>
            <para>
            When you have a protected message you want to read, both identified (addressed messages) 
            and unknown (non-addressed messages), you should use an instance that implements this
            interface.
            </para>
            <para>
            The <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/> class should be used to get an instance that implements
            this interface.
            </para>
            <para>
            This interface assumes you have access to the required artififacts: your decryption certificate
            with private key or a KGSS generated key.  Retreiving the artifacts isn't part of this assembly, but this
            assembly is bundleled with source code that show how it can be done.
            </para>
            <para>
            The library does not occupy itself with the message itself.  It is always treated as an
            array of bytes.  If the message is text, xml or any other format, you and the receiving 
            parties are responsible for the correct encoding/decoding.  The library is also not 
            responsible of the transport of the messages.
            </para>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.SecretKey"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult"/>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer.Unseal(System.IO.Stream)">
             <summary>
             Unseals a protected message addressed to you.
             </summary>
             <remarks>
             <para>
             This method takes a sealed/protected message in the form of a stream and unseals it so it
             can be read.  It uses the personal private key to decrypt, see <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/> 
             how this private key should be provided.
             </para>
             </remarks>
             <param name="sealedData">The protected message that must be unsealed</param>
             <returns>
             <list type="bullet">
             <item>
             <description>The clear message as a temporary file stream that is deleted when the stream is closed</description>
             </item>
             <item>
             <description>The sender information, if known</description>
             </item>
             <item>
             <description>The detailed security information</description>
             </item>
             </list>
             </returns>
             <exception cref="T:System.ArgumentNullException">When sealedData is null</exception>
             <exception cref="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when the message isn't intended for you</exception>
             <exception cref="T:System.InvalidOperationException">When the instance of the object does not have a private key</exception>
             <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
             <example>
             Unseal an addressed message
             <code lang="cs">
             //Create a IDataSealer instance
             IDataUnsealer unsealer = DataUnsealerFactory.Create(SelfEnc, SelfAuth);
             
             UnsealResult result;
             FileStream file = new FileStream("protectedForMe.msg", FileMode.Open);
             using(file)
             {
                 result = unsealer.Unseal(file);
             }
             //Check if the content is in order
             if (result.SecurityInformation.ValidationStatus != ValidationStatus.Valid) throw new Exception(result.SecurityInformation.ToString());
             //Check if sender and receiver used valid and up to spec certificates
             if (result.SecurityInformation.TrustStatus != TrustStatus.Full) throw new Exception(result.SecurityInformation.ToString());
             //Check if the sender is allowed to send a message (application specific)
             VerifySender(result.Sender);
             //Use the message (application specific)
             ImportMessage(result.UnsealedData);
             </code>
             <code lang="vbnet">
             'Create a IDataSealer instance
             Dim unsealer As IDataUnsealer = DataUnsealerFactory.Create(Utils.SelfEnc, Utils.SelfAuth)
            
             Dim result As UnsealResult
             Dim file As New FileStream("protectedForMe.msg", FileMode.Open)
             Using file
                 result = unsealer.Unseal(file)
             End Using
             'Check if the content is in order
             If result.SecurityInformation.ValidationStatus &lt;&gt; ValidationStatus.Valid Then
                 Throw New Exception(result.SecurityInformation.ToString())
             End If
             'Check if sender and receiver used valid and up to spec certificates
             If result.SecurityInformation.TrustStatus &lt;&gt; TrustStatus.Full Then
                 Throw New Exception(result.SecurityInformation.ToString())
             End If
             'Check if the sender is allowed to send a message (application specific)
             VerifySender(result.Sender)
             'Use the message (application specific)
             ImportMessage(result.UnsealedData)
             </code>
             </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer.Unseal(System.Byte[])">
            <summary>
            Unseals a protected in memory message addressed to you.
            </summary>
            <remarks>
            <para>
            This method takes a sealed/protected message in the form of a byte array and unseals it so it
            can be read. It uses the personal private key to decrypt, see <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.DataUnsealerFactory"/> 
            how this private key should be provided.
            </para>
            </remarks>
            <param name="sealedData">The protected message that must be unsealed</param>
            <returns>
            <list type="bullet">
            <item>
            <description>The clear message as an in memory stream</description>
            </item>
            <item>
            <description>The sender information, if known</description>
            </item>
            <item>
            <description>The detailed security information</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentNullException">When sealedData is null</exception>
            <exception cref="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when the message isn't intended for you</exception>
            <exception cref="T:System.InvalidOperationException">When the instance of the object does not have a private key</exception>
            <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation">
            <summary>
            Security information of eighter signatures or encrypted messages.
            </summary>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.Subject">
            <summary>
            Information about the issuer/sender (signature) or recipient (decryption).
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation"/>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation">
            <summary>
            Information about the security checks while unsealing an message.
            </summary>
            <remarks>
            <para>
            Groups information about the outer signature, inner signature and
            encryption/decryption.  There are no specific checks/violations at 
            this level.
            </para>
            <para>
            For a detailed but still comprehensible representation of the instance,
            use the ToString method.  In general there is quite
            a lot of information, so a (tab aware) text viewer is advised.
            </para>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation"/>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.OuterSignature">
            <summary>
            Security information about the outer signature.
            </summary>
            <value>
            Contains information if the encrypted messages was correctly
            signed an by who.
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.Encryption">
            <summary>
            Security information about the encryption/decryption.
            </summary>
            <value>
            Contains information if the encryption was done
            up to spec and the certificate that was used
            to decrypt.
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.InnerSignature">
            <summary>
            Security information about the inner signature.
            </summary>
            <value>
            Contains information if the was correctly signed
            and by who.
            </value>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult">
            <summary>
            The unsealed data and additional info.
            </summary>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.UnsealedData">
            <summary>
            The unsealed/clear data.
            </summary>
            <value>
            <para>
            The unsealed data is never null, if any of the Unseal method of <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.IDataUnsealer"/> fail
            to extract the clear data an exception is thrown. <strong>Warning:</strong> the clear data is always
            provided, even if the security verification detected major violations.  Make sure you check
             <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.SecurityInformation"/> is the data is valid and can be trusted or not.
            </para>
            <para>
            The property is always a stream, but can eighter be a MemoryStream or a Temporaly FileStream, depending
            on the Unseal method that was invoked.  The FileStream does clean up the temporaly file on closing.
            </para>
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.Sender">
            <summary>
            The issuer/sender of the message.
            </summary>
            <value>
            <para>
            The application is supposed to verify that the sender is actualy
            allowed to send this type of messages, the libray only validate
            that the sender information can be used (=trusted) or not.  The rules for validation
            is outside the scope of this project, as is the definition of the list
            of allowed senders.
            </para>
            <para>
            The same information can be retrieved from the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.SecurityInformation"/> property.
            </para>
            </value>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.SecurityInformation">
            <summary>
            The results of the security checks.
            </summary>
            <value>
            This propery must be used to check if the data of the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealResult.UnsealedData"/> is
            valid and can be trusted is not.  You should not accept any messages that have a
            validation status different from <see cref="F:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus.Valid"/> or a truststatus
            different from <see cref="F:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus.Full"/>.
            </value>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus">
            <summary>
            Indicates if object is correct or not.
            </summary>
            <remarks>
            <para>
            The object depends on where this enum is used.  The object can be the message,
            an inner/outer siganture, certificate, etk, ...
            </para>
            <para>
            Correct means that the object isn't altered by somebody other then the issuer
            and that is conforms to the eHealth requirements.
            </para>
            </remarks>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus.Valid">
            <summary>
            <para>
            The object isn't altered and conforms to eHealth requirements.
            </para>
            <para>
            This result means you can use the object, but you still
            have to check if you can trust the issue, <see cref="T:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus"/>.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus.Unsure">
            <summary>
            <para>
            It was impossible to execute all required checks at this time because some information wasn't avialable.
            </para>
            <para>
            You should not use this object.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.SecurityViolations"/> 
            property for the reason and try to fix it (e.g restore internet
            access so the CRL file can be downloaded) and run the verification again on the same object.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus.Unsupported">
            <summary>
            <para>
            It was impossible to execute all required checks because some security information is detected but not supported.
            </para>
            <para>
            You should not use this object.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.SecurityViolations"/> 
            property for the reason and communicate it to the sender.  The sender should then re-create the object
            without the unsupported security information.
            </para>
            </summary>
            
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.ValidationStatus.Invalid">
            <summary>
            <para>
            The checks detected a security violation.
            </para>
            <para>
            You may not use this object.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.SecurityViolations"/> 
            property for the reason and communicate it to the sender.  The sender should then re-create the object,
            this time according to the specs.
            </para>
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus">
            <summary>
            Indicates if the object comes from a trusted issuer or not.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus.Full">
            <summary>
            <para>
            The issuer is fully trusted.
            </para>
            <para>
            You should use the object, but only if you trust this specific issuer.  This value
            only indicates the issuer is who he claims to be, it does not guarantee that
            he is allowed to issue the object for you application.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus.Unsure">
            <summary>
            <para>
            The issuer is not trusted because some checks could not be executed.
            </para>
            <para>
            You should not accept this message, altough it is very lickly the sender is correct.  
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.SecurityViolations"/>  property for the reason.  
            If the reason is the sender, you may request the sender to fix it and resend the message. 
            If the reason is local, it is sufficent to fix it and redo the validation.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.TrustStatus.None">
             <summary>
             <para>
            The issuer is not trusted because some checks failed.
            </para>
            <para>
             You may not accept the message.  The sender information, if present, is probably not correct.
             </para>
             </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation">
            <summary>
            Detailed security information about an unsealed message.
            </summary>
            <remarks>
            <para>
            Indicates which parts of the unsealed message there are security issues:
            <list type="bullet">
            <item>
            <description>Sender, the person that sent and signed the message</description>
            </item>
            <item>
            <description>Data, the content (clear) of the message</description>
            </item>
            <item>
            <description>Recipient, the receiver for who the message is intended</description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.UntrustedSender">
            <summary>
            <para>
            Sender can't be trusted.
            </para>
            <para>
            The sender/issuer information that is in this message can't be trusted.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.OuterSignature"/> or 
            <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.InnerSignature"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.SenderTrustUnknown">
            <summary>
            <para>
            Sender trust is unknown.
            </para>
            <para>
            It is unsure if the sender/issuer information that is in this message can be trusted or not.
            The sender/issuer information that is in this message can't be trusted.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.OuterSignature"/> or 
            <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.InnerSignature"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.UntrustedRecipient">
            <summary>
            <para>
            Receiver can't be trusted.
            </para>
            <para>
            The receiver, that is you, can't be trusted.  This means an encryption/decryption
            certficate is used that is (no longer) valid.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.Encryption"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.RecipientTrustUnknown">
            <summary>
            <para>
            Receiver trust is unknown.
            </para>
            <para>
            It is unsure if the receiver, that is you, can't be trusted or not.  
            This means an encryption/decryption certficate is used could not be validated.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityInformation.Encryption"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.InvalidData">
            <summary>
            <para>
            The data is invalid.
            </para>
            <para>
            The data validation failed, most likely this is due to the fact that the
            data is altered, but it could also mean the sender or receiver information
            is changed.  The <see cref="M:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.#ctor"/> and 
            <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityResult`1.TrustStatus"/> properties reflect the situation
            where the data is altered, but it might as wel be the sender and or receiver
            that are changed.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.UnsealSecurityViolation.DataValidationImpossible">
            <summary>
            <para>
            Data validation is impossible.
            </para>
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation">
            <summary>
            Detailed security information about an Encryption Token (ETK).
            </summary>
            <remarks>
            <para>
            Indicates which parts of the ETK there are security issues:
            <list type="bullet">
            <item>
            <description>Sender, this should be the ETK-depot</description>
            </item>
            <item>
            <description>Data, the content (clear) of the message</description>
            </item>
            <item>
            <description>Recipient, the receiver for who the message is intended</description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.UntrustedSender">
            <summary>
            <para>
            Sender can't be trusted.
            </para>
            <para>
            The sender/issuer information that is in this message can't be trusted,
            indepentant of who the issuer is.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature"/> property for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.SenderTrustUnknown">
            <summary>
            <para>
            Sender trust is unknown.
            </para>
            <para>
            It is unsure if the sender/issuer information that is in this message can be trusted or not.
            The sender/issuer information that is in this message can't be trusted.
            Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature"/> property for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.UntrustedToken">
            <summary>
            <para>
            The encryption certificate (=ETK content) can't be trusted.
            </para>
            <para>
            The ETK contains an encryption certificate, if it isn't trusted
            it should not be used for encryption because the receive will most
            likely not trust it eighter.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.TokenInformation"/>
            property for more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.TokenTrustUnknown">
            <summary>
            <para>
            The encryption certifcate (=ETK content) trust uknown.
            </para>
            <para>
            The ETK contains an encryption certificate, if its trust status can't be determined
            it should not be used for encryption because the receive might also have issues
            determening the trust status.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.TokenInformation"/>
            property for more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.InvalidToken">
            <summary>
            <para>
            The encryption certificate (=ETK content) is invalid.
            </para>
            <para>
            Eighter the encryption certificate in the ETK is not conform to the eHealth requirements
            or the certificate is potentialy altered.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature"/>
            to see if the certificate isn't altered and check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.TokenInformation"/>
            if the certificate is conform to the eHealth requirements.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityViolation.TokenValidationImpossible">
            <summary>
            <para>
            The encryption certificate (=ETK content) could not be validated.
            </para>
            <para>
            Eighter the encryption certificate in the ETK could not be checked for conformity
            or the certificate integrety could not be checked.  Check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Signature"/>
            why the integrity check was inpossible check the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.TokenInformation"/>
            why the conformity could not be dertermined.
            </para>
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation">
            <summary>
            Detailed security information about a security operation, eighter signature or encryption.
            </summary>
            <remarks>
            This library does treat signing and encryption in the say way for certain extend.  Both
            have a certificate, for signing this is the sender for encryption this is the receiver, which
            is called "Subject".  The checks on the subject are exaclty the same for signing and encryption.
            The checks for the signature itself and the decryption are different, therefore both have
            specific violations.
            </remarks>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotAllowedEncryptionAlgorithm">
            <summary>
            <para>
            The content is encyrpted with an unaccepted algorithm (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symetric key
            is used to encrypt the content and only the symetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only the most advanced encryption
            algorithms are allowed.  This violation occurs when a
            less advanced algorithm is used for the encryption of content
            by the symteric key.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotAllowedKeyEncryptionAlgorithm">
            <summary>
            <para>
            The key is encrypted with an unaccepted algorithm (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symetric key
            is used to encrypt the content and only the symetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only the most advanced encryption
            algorithms are allowed.  This violation occurs when a
            less advanced algorithm is used for the encryption of the
            symetric key by the public key of the receiver.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotAllowedEncryptionKeySize">
            <summary>
            <para>
            The key is encrypted with an unacceptable key size (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symetric key
            is used to encrypt the content and only the symetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only keys of a certains size are allowed.  
            This violation occurs when a the public key of the receiver is
            smaller then the minimuum size.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotSigned">
            <summary>
            <para>
            There was no signature present (signing).
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotFoundSigner">
            <summary>
            <para>
            The signer info wasn't present (signing).
            </para>
            <para>
            Normaly a sealed message contains the information about the signer,
            if this information is missing it is impossible to verify the
            signature and this violation is raised.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotSignatureValid">
            <summary>
            <para>
            The signature was invalid (signing).
            </para>
            <para>
            When this violation is raised, eigther the data is altered
            or the issuer information is subsituted.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotAllowedSignatureDigestAlgorithm">
            <summary>
            <para>
            The digest algorithm for signing isn't allowed (signing).
            </para>
            <para>
            In most cases a signature consist of an encrypted
            digest of the content.  Therefore a signature algorithm
            consists of a digest algorithm and a encryption algorithm.
            The encryption algorithm of the signature is not related
            to the encryption algorithm of the encryption.
            </para>
            <para>
            For security reaons only the most advanced algorithms are
            allowed.  This violation occurs when the digest algorithm of the 
            signature is less advanced then required.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.NotAllowedSignatureEncryptionAlgorithm">
            <summary>
            <para>
            The encryption algorithm for signing isn't allowed (signing).
            </para>
            <para>
            In most cases a signature consist of an encrypted
            digest of the content.  Therefore a signature algorithm
            consists of a digest algorithm and a encryption algorithm.
            The encryption algorithm of the signature is not related
            to the encryption algorithm of the encryption.
            </para>
            <para>
            For security reaons only the most advanced algorithms are
            allowed.  This violation occurs when the encryption algorithm of the 
            signature is less advanced then required.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.UntrustedSubject">
            <summary>
            <para>
            The subject information should not be trusted (common).
            </para>
            <para>
            The issuer (signing) or receiver (encryption) information failed to
            validate. See the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.Subject"/> property
            for more information.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityViolation.SubjectTrustUnknown">
            <summary>
            <para>
            The subject information should not be validated (common).
            </para>
            <para>
            It was impossible to validate the issuer (signing) or receiver (encryption) information. 
            See the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.Subject"/> property
            for more information.
            </para>
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation">
            <summary>
            Detailed security information about a certificate (=Subject, Receiver, Issuer, Sender,...).
            </summary>
            <remarks>
            <para>
            Certificate are validated on a number of point.  Each of this validation can result in
            its own security violation.  See the different member for more information.
            </para>
            <para>
            Each certificate has an issuer.  Security violation of these issues also cause a security
            violation on the certificate itself.
            </para>
            </remarks>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.UntrustedIssuer">
            <summary>
            The issue was invalid. See <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.Subject"/> proparty for more information.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.IssuerTrustUnknown">
            <summary>
            The issuer validation was impossible. See <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.SecurityInformation.Subject"/> proparty for more information.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NotValidKeyType">
            <summary>
            <para>
            The public key in the certificate isn't supported, currently on RSA and DSA are. 
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NotValidKeySize">
            <summary>
            <para>
            The size of the key for this certificate is less then the required minimuum.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NotTimeValid">
            <summary>
            <para>
            The certificate is not yet or no longer valid at the time of use.
            </para>
            <para>
            For encryption the time is always validated with the current time since
            the validation always occures toghether with the decryption.  For signing certificates
            the siging time is used for validation, is the signing time isn't available
            the current time is used.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.Revoked">
            <summary>
            <para>
            The certificate is revoked according to the windows revocation mechanism.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NotSignatureValid">
            <summary>
            <para>
            The signature of by certificate by it issuer isn't valid.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NotValidForUsage">
            <summary>
            <para>
            The certificate is incorrecty used.
            </para>
            <para>
            This can be eighter a signing certificate that is used
            for encryption or visa versa.  It can also be that a non
            CA certificate is used to issue a certificate.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.UntrustedRoot">
            <summary>
            <para>
            The root certificate could not be found in the trusted CA certificate store of you machine.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.RevocationStatusUnknown">
            <summary>
            <para>
            The revocation status of the certificate could not be determined.
            </para>
            <para>
            When the certificate contains revocation information windows recognises
            but windows can't retreive it, this violation is raised.  By default windows
            only supports CRLs.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.Cyclic">
            <summary>
            <para>
            The certificate chain is cyclic.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.InvalidExtension">
            <summary>
            The certificate contains an invalid extension.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.InvalidPolicyConstraints">
            <summary>
            The certificate violates a policy contraint.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.InvalidBasicConstraints">
            <summary>
            the certificate violates a basic constraint.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.InvalidNameConstraints">
            <summary>
            The certificate violates a name constraint.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.HasNotSupportedNameConstraint">
            <summary>
            The certificate contains a name constraint that can't be validated by windows.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.HasNotDefinedNameConstraint">
            <summary>
            The certificates violates a name contraint because its name wasn't defined.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.HasNotPermittedNameConstraint">
            <summary>
            The certificates violates a name contraint because its name is explicity not permitted.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.HasExcludedNameConstraint">
            <summary>
            The certificates violates a name contraint because its name is exlcuded.
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.OfflineRevocation">
            <summary>
            <para>
            The revocation information used was cached.
            </para>
            <para>
            CRLs, which are used for revocation, have a certain validity period a can
            therefore be cached.  The "violation" only indicates a cached version is used,
            this does not mean the certificate is invalid.
            </para>
            <para>
            If you application does not allow offline revocation, you must explecitely 
            check the validation result.
            </para>
            </summary>
        </member>
        <member name="F:Siemens.EHealth.Etee.Crypto.Decrypt.CertSecurityViolation.NoIssuanceChainPolicy">
            <summary>
            Specifies that there is no certificate policy extension in the certificate. This error would occur if a group policy has specified that all certificates must have a certificate policy.
            </summary>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.EncryptionToken">
            <summary>
            Represents an ETK.
            </summary>
            <remarks>
            <para>
            Thi class represents an ETK retrieved from the ETK-Depot.  It can be used to seal messages so it can only be viewed by the party
            that owns the ETK and therefore has the private key corresponding to this.  It is possible, and even advised, to cache the ETK for
            parties you will probably require in the future.
            </para>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.EncryptionToken.#ctor(System.String)">
            <summary>
            Constructor for the string representation of the ETK. 
            </summary>
            <remarks>
            <para>
            The xml representation of the "GetEtkResponse" of the ETK-Depot web service
            contains an element "ETK" of which is content can be provided to this
            constructor.  Normaly you will not have access to the xml representation,
            so it is unlikely you will need this constuctor for this reason.
            </para>
            <para>
            If you use a cache that can't handle binary data, use this constuctor
            to use an instance from cache.
            </para>
            </remarks>
            <param name="data">Base64 encoded representation of the ETK</param>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.EncryptionToken.#ctor(System.Byte[])">
            <summary>
            Constructor for the binary represenation of the ETK.
            </summary>
            <remarks>
            <para>
            The binary represenation of the "GetEtkResponse" of the ETK-Depot web service
            contains an byte array item that can be provided to this constructor.
            </para>
            <para>
            If you use a cahce that can handle binary data, use this constructor
            to use an instance from cache.
            </para>
            </remarks>
            <param name="data">raw ETK</param>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.EncryptionToken.GetEncoded">
            <summary>
            Gets the byte representation of the ETK.
            </summary>
            <returns>Binary form of the ETK, should be saved in a cache</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.EncryptionToken.GetEncodedAsString">
            <summary>
            Gets the string representation of the ETK.
            </summary>
            <returns>String form of the ETK, should be saved in a cache</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.EncryptionToken.Verify">
            <summary>
            Verifies if the ETK is still valid and can be trusted.
            </summary>
            <remarks>
            <para>
            This method checks if the ETK is issued by a trusted party.  Tust means
            the root certificate is trusted by the computer it is running on and all
            validation checks, including revocation, are successful.  Root
            certificates are trusted by the computer if present in the 
            <see cref="F:System.Security.Cryptography.X509Certificates.StoreName.Root"/> store.
            </para>
            <para>
            <strong>The method does NOT verify that the ETK is issued by eHealth</strong>,
            it only verifies the issuer is who he claims to be.  It is the caller of this method's 
            responsablity to check if this specific issuer (or sender) is trusted for issuing ETKs or not.
            Use the <see cref="P:Siemens.EHealth.Etee.Crypto.Decrypt.EtkSecurityInformation.Sender"/> property of the return value to get the certificate of 
            the issuer and check the subject name or any other attribute to determine who is the issuer/sender.
            </para>
            </remarks>
            <returns>Detailed information about the verification</returns>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer">
            <summary>
            Interface to protect messages according to the eHealth End-To-End encryption.
            </summary>
            <remarks>
            <para>
            When you have a message that you want to protect and send to one or more recipients, 
            both identified (addressed messages) and unknown (non-addressed messages), you should 
            use an instance that implements this interface.
            </para>
            <para>
            The <see cref="T:Siemens.EHealth.Etee.Crypto.Encrypt.DataSealerFactory"/> class should be used to get an instance that implements
            this interface.
            </para>
            <para>
            This interface assumes you have access to the required artififacts: the receivers ETK 
            or a KGSS generated key.  Retreiving the artifacts isn't part of this assembly, but this
            assembly is bundleled with source code that show how it can be done.
            </para>
            <para>
            The library does not occupy itself with the message itself.  It is always treated as an
            array of bytes.  If the message is text, xml or any other format, you and the receiving 
            parties are responsible for the correct encoding/decoding.  The library is also not 
            responsible of the transport of the messages.
            </para>
            </remarks>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.Encrypt.DataSealerFactory"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.EncryptionToken"/>
            <seealso cref="T:Siemens.EHealth.Etee.Crypto.SecretKey"/>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(Siemens.EHealth.Etee.Crypto.EncryptionToken,System.Byte[])">
            <summary>
            Seals a clear in memory message for one recipient.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a byte array and seals it so it
            can only be read by one single recipient.
            </para>
            </remarks>
            <param name="token">ETK token, only the owner of this token will be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <returns>The sealed message, this should be transported to the receivers</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.Collections.ObjectModel.ReadOnlyCollection{Siemens.EHealth.Etee.Crypto.EncryptionToken},System.Byte[])">
            <summary>
            Seals a clear in memory message for multiple recipients.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a byte array and seals it so it
            can only be read by all the recipients that are specified.
            </para>
            </remarks>
            <param name="tokens">ETK tokens, only the owners of these tokens will be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <returns>The sealed message, this should be transported to the receivers</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(Siemens.EHealth.Etee.Crypto.EncryptionToken,System.IO.Stream)">
            <summary>
            Seals a clear message for a single recipient.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a stream and seals it so it
            can only be read by one single recipient.
            </para>
            <para>
            To limit the amount of memory needed, temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="token">ETK token, only the owner of this token will be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for one known recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(Utils.SelfAuth);
            
            //Read the etk of a specific reciever
            EncryptionToken receiver = new EncryptionToken(Utils.ReadFully("other.etk"));
            Utils.Check(receiver.Verify()); //verify if it is (still) correct
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(receiver, file);
            }
            </code>
            <code lang="vbnet">
            'Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            Dim sealer As IDataSealer = DataSealerFactory.Create(Utils.SelfAuth)
            
            'Read the etk of a specific reciever
            Dim receiver As New EncryptionToken(Utils.ReadFully("other.etk"))
            'verify if it is (still) correct
            Utils.Check(receiver.Verify())
            
            'Seal as stream
            Dim output As Stream
            Dim file As New FileStream("text.txt", FileMode.Open)
            Using file
                output = sealer.Seal(receiver, file)
            End Using
            </code>
            </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.Collections.ObjectModel.ReadOnlyCollection{Siemens.EHealth.Etee.Crypto.EncryptionToken},System.IO.Stream)">
            <summary>
            Seals a clear message for multiple recipients.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a stream and seals it so it
            can only be read by all the recipients that are specified.
            </para>
            <para>
            To limit the amount of memory needed, temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="tokens">ETK tokens, only the owners of this tokens will be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for several known recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(Utils.SelfAuth);
            
            //Read the etk of a specific reciever
            EncryptionToken receiver1 = new EncryptionToken(Utils.ReadFully("other1.etk"));
            Utils.Check(receiver1.Verify()); //verify if it is (still) correct
            
            //Read the etk of another specific reciever
            EncryptionToken receiver2 = new EncryptionToken(Utils.ReadFully("other2.etk"));
            Utils.Check(receiver2.Verify()); //verify if it is (still) correct
            
            //Create a list for the recievers, only one in this case
            List&lt;EncryptionToken&gt; receivers = new List&lt;EncryptionToken&gt;();
            receivers.Add(receiver1);
            receivers.Add(receiver2);
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(new ReadOnlyCollection&lt;EncryptionToken&gt;(receivers), file);
            }
            </code>
            <code lang="vbnet">
            'Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            Dim sealer As IDataSealer = DataSealerFactory.Create(Utils.SelfAuth)
            
            'Read the etk of a specific reciever
            Dim receiver1 As New EncryptionToken(Utils.ReadFully("other1.etk"))
            'verify if it is (still) correct
            Utils.Check(receiver1.Verify())
            
            'Read the etk of another specific reciever
            Dim receiver2 As New EncryptionToken(Utils.ReadFully("other2.etk"))
            'verify if it is (still) correct
            Utils.Check(receiver2.Verify())
            
            'Create a list for the recievers, only one in this case
            Dim receivers As New List(Of EncryptionToken)
            receivers.Add(receiver1)
            receivers.Add(receiver2)
            
            'Seal as stream
            Dim output As Stream
            Dim file As New FileStream("text.txt", FileMode.Open)
            Using file
                output = sealer.Seal(New ReadOnlyCollection(Of EncryptionToken)(receivers), file)
            End Using
            </code>
            </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.Byte[],Siemens.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Seals a clear message for unspecified recipients.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a byte array and seals it so it
            can only be read by the recipients that have access to the same shared key.  This shared key
            should be retrieved from KGSS.
            </para>
            </remarks>
            <param name="unsealed">The clear message that must be protected</param>
            <param name="key">KGSS shared but secret key, only parties that have access to the same key can read the messages</param>
            <returns>The sealed message, this should be transported to the receivers</returns>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.IO.Stream,Siemens.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Seals a clear message for unspecified recipients.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a stream and seals it so it
            can only be read by the recipients that have access to the same shared key.  This shared key
            should be retrieved from KGSS.
            </para>
            <para>
            To limit the amount of memory needed, temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="unsealed">The clear message that must be protected</param>
            <param name="key">KGSS shared but secret key, only parties that have access to the same key can read the messages</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for both known and unknown recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(Utils.SelfAuth);
            
            //Create a secret key, keyId and Key are retreived from KGSS
            byte[] keyId;
            byte[] key = Utils.GetNewSecretKey(out keyId);
            SecretKey skey = new SecretKey(keyId, key);
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(file, skey);
            }
            </code>
            <code lang="vbnet">
            'Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            Dim sealer As IDataSealer = DataSealerFactory.Create(Utils.SelfAuth)
            
            'Create a secret key, keyId and Key are retreived from KGSS
            Dim keyId() As Byte
            Dim key() As Byte = Utils.GetNewSecretKey(keyId)
            Dim skey As New SecretKey(keyId, key)
            
            'Seal as stream
            Dim output As Stream
            Dim file As New FileStream("text.txt", FileMode.Open)
            Using file
                output = sealer.Seal(file, skey)
            End Using
            </code>
            </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.Collections.ObjectModel.ReadOnlyCollection{Siemens.EHealth.Etee.Crypto.EncryptionToken},System.Byte[],Siemens.EHealth.Etee.Crypto.SecretKey)">
             <summary>
             Seals a clear message for multiple recipients and unspecified recipients as the same time.
             </summary>
             <remarks>
             <para>
             This method takes a clear message in the form of a byte array and seals it so it
             can only be read by the recipients that that are specified or have access to the 
             same shared key.  This shared key should be retrieved from KGSS, the specified recipients
             can be retrieved from the ETK-Depot.
             </para>
             </remarks>
             <param name="tokens">ETK tokens, the owners of this tokens will also be able to read the message</param>
             <param name="unsealed">The clear message that must be protected</param>
             <param name="key">KGSS shared but secret key, parties that have access to the same key can also read the messages</param>
             <returns>The sealed message, this should be transported to the receivers</returns>
             <example>
             Sealing a message for both known and unknown recipient. 
             <code lang="cs">
             String msg = "My message";
            
             //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
             IDataSealer sealer = DataSealerFactory.Create(Utils.SelfAuth);
             
             //Create a secret key, keyId and Key are retreived from KGSS
             byte[] keyId;
             byte[] key = Utils.GetNewSecretKey(out keyId);
             SecretKey skey = new SecretKey(keyId, key);
             
             //Read the etk of a specific reciever
             EncryptionToken receiver1 = new EncryptionToken(Utils.ReadFully("other1.etk"));
             Utils.Check(receiver1.Verify()); //verify if it is (still) correct
             
             //Read the etk of another specific reciever
             EncryptionToken receiver2 = new EncryptionToken(Utils.ReadFully("other2.etk"));
             Utils.Check(receiver2.Verify()); //verify if it is (still) correct
             
             //Create a list for the recievers, only one in this case
             List&lt;EncryptionToken&gt; receivers = new List&lt;EncryptionToken&gt;();
             receivers.Add(receiver1);
             receivers.Add(receiver2);
             
             //Seal a string message, encoded as UTF8.
             byte[] output = sealer.Seal(new ReadOnlyCollection&gt;EncryptionToken&lt;(receivers), Encoding.UTF8.GetBytes(msg), skey);
             </code>
             <code lang="vbnet">
             Dim msg As String = "My message"
             
             'Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
             Dim sealer As IDataSealer = DataSealerFactory.Create(Utils.SelfAuth)
             
             'Create a secret key, keyId and Key are retreived from KGSS
             Dim keyId() As Byte
             Dim key() As Byte = Utils.GetNewSecretKey(keyId)
             Dim skey As New SecretKey(keyId, key)
             
             'Read the etk of a specific reciever
             Dim receiver1 As New EncryptionToken(Utils.ReadFully("other1.etk"))
             'verify if it is (still) correct
             Utils.Check(receiver1.Verify())
             
             'Read the etk of another specific reciever
             Dim receiver2 As New EncryptionToken(Utils.ReadFully("other2.etk"))
             'verify if it is (still) correct
             Utils.Check(receiver2.Verify())
             
             'Create a list for the recievers, only one in this case
             Dim receivers As New List(Of EncryptionToken)
             receivers.Add(receiver1)
             receivers.Add(receiver2)
             
             'Seal a string message, encoded as UTF8.
             Dim output() As Byte = sealer.Seal(New ReadOnlyCollection(Of EncryptionToken)(receivers), Encoding.UTF8.GetBytes(msg), skey)
             </code>
             </example>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer.Seal(System.Collections.ObjectModel.ReadOnlyCollection{Siemens.EHealth.Etee.Crypto.EncryptionToken},System.IO.Stream,Siemens.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Seals a clear message for multiple recipients and unspecified recipients as the same time.
            </summary>
            <remarks>
            <para>
            This method takes a clear message in the form of a byte array and seals it so it
            can only be read by the recipients that that are specified or have access to the 
            same shared key.  This shared key should be retrieved from KGSS, the specified recipients
            can be retrieved from the ETK-Depot.
            </para>
            <para>
            To limit the amount of memory needed, temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="tokens">ETK tokens, the owners of this tokens will also be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <param name="key">KGSS shared but secret key, parties that have access to the same key can also read the messages</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for both known and unknown recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(Utils.SelfAuth);
            
            //Create a secret key, keyId and Key are retreived from KGSS
            byte[] keyId;
            byte[] key = Utils.GetNewSecretKey(out keyId);
            SecretKey skey = new SecretKey(keyId, key);
            
            //Read the etk of a specific reciever
            EncryptionToken receiver1 = new EncryptionToken(Utils.ReadFully("other1.etk"));
            Utils.Check(receiver1.Verify()); //verify if it is (still) correct
            
            //Read the etk of another specific reciever
            EncryptionToken receiver2 = new EncryptionToken(Utils.ReadFully("other2.etk"));
            Utils.Check(receiver2.Verify()); //verify if it is (still) correct
            
            //Create a list for the recievers, only one in this case
            List&lt;EncryptionToken&gt; receivers = new List&lt;EncryptionToken&gt;();
            receivers.Add(receiver1);
            receivers.Add(receiver2);
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(new ReadOnlyCollection&lt;EncryptionToken&gt;(receivers), file, skey);
            }
            </code>
            <code lang="vbnet">
            'Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            Dim sealer As IDataSealer = DataSealerFactory.Create(Utils.SelfAuth)
            
            'Create a secret key, keyId and Key are retreived from KGSS
            Dim keyId() As Byte
            Dim key() As Byte = Utils.GetNewSecretKey(keyId)
            Dim skey As New SecretKey(keyId, key)
            
            'Read the etk of a specific reciever
            Dim receiver1 As New EncryptionToken(Utils.ReadFully("other1.etk"))
            'verify if it is (still) correct
            Utils.Check(receiver1.Verify())
            
            'Read the etk of another specific reciever
            Dim receiver2 As New EncryptionToken(Utils.ReadFully("other2.etk"))
            'verify if it is (still) correct
            Utils.Check(receiver2.Verify())
            
            'Create a list for the recievers, only one in this case
            Dim receivers As New List(Of EncryptionToken)
            receivers.Add(receiver1)
            receivers.Add(receiver2)
            
            'Seal as stream
            Dim output As Stream
            Dim file As New FileStream("text.txt", FileMode.Open)
            Using file
                output = sealer.Seal(New ReadOnlyCollection(Of EncryptionToken)(receivers), file, skey)
            End Using
            </code>
            </example>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.Encrypt.DataSealerFactory">
            <summary>
            <see cref="T:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer"/> factory class.
            </summary>
            <remarks>
            This class should be used to get an instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer"/>
            class.  This class is static, with only one static method. 
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.Encrypt.DataSealerFactory.Create(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Creates an instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.Encrypt.IDataSealer"/> inferface.
            </summary>
            <remarks>
            <para>
            Creates an instance specific for one sending party this can be is a person, company, hospital or any other entity.
            This instance is specific for a sender, so if your program supports multiple senders it will need multiple instance.
            The instances aren't thread safe, so you also need multiple instance or a locking mechanism if you have multiple
            threads.
            </para>
            <para>
            Each instances has an authentication certficiate with it.  This is normaly issued by eHealth, but any 
            <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2"/> will do as long as it is compliant with the eHealth End-To-End Encyption standards.
            The IDataSealer instance does not verify if the certificate is compliant, only the IDataUnsealer instance does that.
            If using a non eHealth authentication certificate, make sure it is compliant and trusted by the recieving parties.
            </para>
            <para>
            The certificate can be eighter loaded from the standard windows certificate store, for this the eHealth .p12 must
            be imported into the windows certificate store.  It is also possible to open a .p12 or .pfx file directly, but this
            does not work with the standard eHealth .p12 file.  The reason is that <see cref="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)"/>
            only supports files with one private key, the standard eHealth .p12 files have two.  You must split the eHealth .p12
            into two seperate .p12 files, one for the authantication key and none for the encryption key.
            </para>
            </remarks>
            <example>
            Requesting the user to select his own authentication certificate
            <code lang="cs">
            IDataSealer sealer;
            
            //Open the Windows certificate store, in this case my own certificates specific for my windows users.
            X509Store myStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            myStore.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
            try
            {
                //Filter out all non signature certificates.
                X509Certificate2Collection mySignCerts = myStore.Certificates.Find(X509FindType.FindByKeyUsage, X509KeyUsageFlags.DigitalSignature, true);
                
                //Allow the user to select its own certificate
                X509Certificate2Collection selected = X509Certificate2UI.SelectFromCollection(mySignCerts, "Sender Certificate", "Select your eHealth authentication certificate", X509SelectionFlag.SingleSelection);
            
                //if user did not select a certificate, nofify him he should
                if (selected.Count != 1) throw new Exception("You must select a certificate");
               
                sealer = DataSealerFactory.Create(selected[0]);
            }
            finally
            {
                myStore.Close();
            }
            </code>
            </example>
            <param name="sender">The (eHealth) certificate to use for signing the protected messages</param>
            <returns>Instance of the IDataSealer that can be used to protect messages in name of the provided sender</returns>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException">
            <summary>
            Exception indication the protected message can't be processed.
            </summary>
            <remarks>
            When a protected message is not compliant in a way that it is impossible to
            process it, an InvalidMessageException is thrown.
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.InvalidMessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Siemens.EHealth.Etee.Crypto.InvalidMessageException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param>
        </member>
        <member name="T:Siemens.EHealth.Etee.Crypto.SecretKey">
            <summary>
            Represents an symetric secret key or Key Encryption Key.
            </summary>
            <remarks>
            <para>
            This class represents a secret, but shared, key from the KGSS.  It can be used to seal messages so it can only be viewed by the 
            that the KGSS allows to retreive the same key.  It isn't advised to use the same key for more then one message.  
            </para>
            </remarks>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.SecretKey.#ctor(System.String,System.String)">
            <summary>
            Constructor for the string representation of the KEK.
            </summary>
            <remarks>
            <para>
            The xml representation of the "GetNewKeyResponseContent" contains both the id als the key
            that can be provided to this constructor.  The xml representation "GetKeyResponseContent"
            only contains the key param for this constructor, the id param should be the same as
            in the xml representation of "GetKeyRequestContent".
            </para>
            </remarks>
            <param name="id">The ID of the KEK.  Senders get it from the KGSS web service, receivers 
            get it directly from the sender in an application spefic way.</param>
            <param name="key">The KEK itself, always retreived from the KGSS web service</param>
        </member>
        <member name="M:Siemens.EHealth.Etee.Crypto.SecretKey.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constuctor for the binary representation of the KEK.
            </summary>
                    /// <remarks>
            <para>
            The binary representation of the "GetNewKeyResponseContent" contains both the id als the key
            that can be provided to this constructor.  The binary representation "GetKeyResponseContent"
            only contains the key param for this constructor, the id param should be the same as
            in the binary representation of "GetKeyRequestContent".
            </para>
            </remarks>
            <param name="id">The ID of the KEK.  Senders get it from the KGSS web service, receivers 
            get it directly from the sender in an application spefic way</param>
            <param name="key">The KEK itself, always retreived from the KGSS web service</param>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.SecretKey.Id">
            <summary>
            The binary form of the KEK id.
            </summary>
            <remarks>
            <para>
            This is the only part of the KEK that the application itself must transmit to the reciever,
            together with the message itself.  This is public information, so there is no need to seal it
            for transport.
            </para>
            <para>
            Use this representation of the KEK id if the transport support binary information.
            </para>
            </remarks>
        </member>
        <member name="P:Siemens.EHealth.Etee.Crypto.SecretKey.IdString">
            <summary>
            The string form of the KEK id.
            </summary>
            <remarks>
            <para>
            This is the only part of the KEK that the application itself must transmit to the reciever,
            together with the message itself.  This is public information, so there is no need to seal it
            for transport.
            </para>
            <para>
            Use this representation of the KEK id if the transport only support text information.
            </para>
            </remarks>
        </member>
    </members>
</doc>
