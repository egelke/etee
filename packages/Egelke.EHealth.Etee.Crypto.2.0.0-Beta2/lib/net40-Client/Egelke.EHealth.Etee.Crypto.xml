<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Egelke.EHealth.Etee.Crypto</name>
    </assembly>
    <members>
        <member name="P:Egelke.EHealth.Etee.Crypto.Configuration.EteeActiveConfig.ClockSkewness">
            <summary>
            The max difference between the different clocks.
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Configuration.Settings">
            <summary>
            Global settings class of the library.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.Default">
            <summary>
            The default instance of the settings class, always use this.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.TimestampGracePeriod">
            <summary>
            The max delay between the time-stamp and signing time.
            </summary>
            <remarks>
            The default value is 5 minutes.
            </remarks>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.InMemorySize">
            <summary>
            The size of the message before the temp file directory is used instead of a memory stream.
            </summary>
            <value>
            <para>
            The default value is 1048576 or 1MB.
            </para>
            <para>
            This setting isn't used for messages generated with the eHealth 1.6 version of the library.
            </para>
            </value>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Sender.EhDataSealerFactory">
            <summary>
            <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> factory class for sealed message creators/senders.
            </summary>
            <remarks>
            This instance is specific for a sender, so if your program supports multiple senders it will need multiple instance.
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EhDataSealerFactory.Create(Egelke.EHealth.Etee.Crypto.Level,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for B-Level only.
            </summary>
            <remarks>
            <para>
            Each instances has an authentication and optionally a signing certificate.  Which can either be eID or eHealth certificates.
            In case of eHealth certificates, only the authentication certificate must be provided, it also be used as signing certificate.
            In case of eID certificates, both the authentication and signing certificate of the same person should be provided, the PIN will
            only be requested twice because of a windows limitation.
            </para>
            <para>
            eHealth certificate can only be loaded from the standard windows certificate store, the eHealth provided .p12 must
            be imported into the windows certificate store with <strong>exportable</strong> key.  It isn't possible to use the eHealth .p12 directly, because
            <see cref="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)"/>
            only supports files with one private key, the standard eHealth .p12 files have two.  For compatibility with the .Net Xades
            library, the eHealth .p12 library should be imported via the <c>EHealthP12</c>-class of the eH-I library.
            </para>
            </remarks>
            <example>
            Requesting the user to select his own authentication certificate
            <code lang="cs">
            IDataSealer sealer;
            
            //Open the Windows certificate store, in this case my own certificates specific for my windows users.
            X509Store myStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            myStore.Open(OpenFlags.OpenExistingOnly | OpenFlags.ReadOnly);
            try
            {
                //Filter out all non signature certificates.
                X509Certificate2Collection myEhCerts = myStore.Certificates.Find(X509FindType.FindByKeyUsage, X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.NonRepudiation, true);
                
                //Allow the user to select its own certificate
                X509Certificate2Collection selected = X509Certificate2UI.SelectFromCollection(myEhCerts, "Sender Certificate", "Select your eHealth certificate", X509SelectionFlag.SingleSelection);
            
                //if user did not select a certificate, notify him he should
                if (selected.Count != 1) throw new Exception("You must select a certificate");
               
                sealer = DataSealerFactory.Create(Level.B_Level, selected[0]);
            }
            finally
            {
                myStore.Close();
            }
            </code>
            </example>
            <param name="authSign">The eHealth certificate to use for proving the origin of the message.  The certificate key must be <strong>exportable</strong>!</param>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <returns>Instance of the IDataSealer that can be used to protect messages in name of the provided sender (i.e. authentication and signature certificate)</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EhDataSealerFactory.Create(Egelke.EHealth.Etee.Crypto.Level,Egelke.EHealth.Client.Pki.ITimestampProvider,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for all levels except for B-Level.
            </summary>
            <remarks>
            Uses a time-stamp authority to indicate the time when the message was created. See the eH-I TSA module for possible implementation of existing authorities.
            See the message definition for which authority must be used if any, the eH-I TSA module provides clients for both eHealth and Fedict but can be extended to any
            authority that returns compliant time-stamp-tokens.
            </remarks>
            <param name="authSign">The eHealth certificate to use for proving the origin of the message.  The certificate key must be <strong>exportable</strong>!</param>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <param name="timestampProvider">The client of the time-stamp authority</param>
            <seealso cref="!:Create(X509Certificate2, X509Certificate2, Level)"/>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EhDataSealerFactory.CreateForTimemarkAuthority(Egelke.EHealth.Etee.Crypto.Level,System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for all levels except for B-Level.
            </summary>
            <remarks>
            The returned data sealer assumes that the messages will be send via a time-mark authority and will therefore not attempt to add a time-stamp.
            The data sealer has not direct dependency to this time-mark authority, it is the caller that must send it himself.
            </remarks>
            <param name="authSign">The eHealth certificate to use for proving the origin of the message.  The certificate key must be <strong>exportable</strong>!</param>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <seealso cref="!:Create(X509Certificate2, X509Certificate2, Level)"/>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.DataCompleterFactory">
            <summary>
            <see cref="T:Egelke.EHealth.Etee.Crypto.Store.IDataCompleter"/> factory class for sealed message stores.
            </summary>
            <remarks>
            <para>
            Intended for sealed messages stores that will complete sealed messages but not necessary seal them itself.
            Often these message store are time-mark authorities, but this isn't a required.
            </para>
            <para>
            Can't be used to complete B-Level since there is nothing to complete with that level.
            </para>
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataCompleterFactory.Create(Egelke.EHealth.Etee.Crypto.Level,Egelke.EHealth.Client.Pki.ITimestampProvider)">
            <summary>
            Creates a completer to extend messages with validation data and time-stamp.
            </summary>
            <remarks>
            <para>
            The resulting completer add a time-stamp via the time-stamp authority and optionally revocation information to the message.
            It is illegal to call this method with B-Level since this would not change the message in any way.
            </para>
            </remarks>
            <param name="level">The required level the completer must produce: T-Level, LT-Level or LTA-Level</param>
            <param name="timestampProvider">The client of the time-stamp authority</param>
            <returns>The completer of the required level that will used the provided time-stamp authority client</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataCompleterFactory.CreateForTimeMarkAuthority(Egelke.EHealth.Etee.Crypto.Level)">
            <summary>
            Creates a completer to extend messages that will be send to a time-mark authority with validation data
            </summary>
            <remarks>
            <para>
            The resulting completer add revocation information to the message.
            It is illegal to call this method with B-Level or T-Level since this would not change the message in any way.
            </para>
            </remarks>
            <param name="level">The required level the completer must produce: LT-Level or LTA-Level</param>
            <returns>The completer of the required level to by a client of a time-mark authority</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataCompleterFactory.CreateAsTimeMarkAuthority(Egelke.EHealth.Etee.Crypto.Level)">
            <summary>
            Creates a completer to extend messages with validation data but not time-stamp.
            </summary>
            <remarks>
            The resulting completer does not add a time-stamp because it is either called by a time-marking authority itself or
            the message will be send to one.
            </remarks>
            <param name="level">The required level the completer must produce: T-Level, LT-Level or LTA-Level</param>
            <returns>The completer of the required level to be used by a time-mark authority</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.ITmaDataCompleter">
            <summary>
            Message verifier for time-mark authorities.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.ITmaDataCompleter.Complete(System.IO.Stream,Egelke.EHealth.Etee.Crypto.Store.TimemarkKey@)">
            <summary>
            Completes the provided message and returns the time-mark key.
            </summary>
            <remarks>
            Has an output parameter that will provide the time-mark key.  As a time-mark authority
            you are supposed use this key for the audit trail used for time-marking.  It must also
            be possibel to lookup the time-mark of the message via this key.
            </remarks>
            <seealso cref="M:Egelke.EHealth.Etee.Crypto.Store.IDataCompleter.Complete(System.IO.Stream)"/>
            <param name="sealedData">The sealed message to which the information must be added</param>
            <param name="timemarkKey">The time-mark key to be linked to the message</param>
            <exception cref="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException">When the provided message isn't valid</exception>
            <returns>The sealed message to which the information is added</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.IDataCompleter">
            <summary>
            Message completer non time-mark authority.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.IDataCompleter.Complete(System.IO.Stream)">
            <summary>
            Completes the provided message.
            </summary>
            <remarks>
            <para>
            Completes the authentication part of the message, it does not decrypt the message
            or changes the signature (non-repudiation) part.  It does not require the 
            possession of any decryption key and keeps the confidiality of the content.
            </para>
            <para>
            The level of the returned messages depends on the level specified during creation. When required
            by the level, a time-stamp is added via the provided time-stamp authority.  In case of a 
            time-mark authority, not time information is added.
            </para>
            <para>
            The returned <c>Stream</c> is either a memory stream or a stream to a temporally file that is
            deleted when the stream is closed.  Which depends on the <see cref="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.InMemorySize"/> setting.
            </para>
            </remarks>
            <param name="sealedData">The sealed message to which the information must be added</param>
            <exception cref="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException">When the provided message isn't valid</exception>
            <returns>The sealed message to which the information is added</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Level">
            <summary>
            Security levels based to the "CAdES Baseline Profile" levels.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.B_Level">
            <summary>
            Baseline level.
            </summary>
            <remarks>
            No time validation, no time-stamp or time-mark is required (but time-stamps are processed if encountered)
            No revocation information is embedded, revocation is verified via embedded and/or online information (but the embedded info will be quicly outdated).
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.T_Level">
            <summary>
            Time stamped/marked level.
            </summary>
            <remarks>
            Same as <see cref="F:Egelke.EHealth.Etee.Crypto.Level.B_Level"/> with time validation, requires a time-stamp or time-mark from a time-mark authority (e.g. ehBox, Recip-e... or intenal).
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.L_Level">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.A_level">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.LT_Level">
            <summary>
            Long lived time stamped/marked level.
            </summary>
            <remarks>
            Same as <see cref="F:Egelke.EHealth.Etee.Crypto.Level.T_Level"/> where revocation information is embedded during sealing, unsealing will still resolve online information if needed.
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Level.LTA_Level">
            <summary>
            Long lived archivable time stamped/marked level.
            </summary>
            <remarks>
            <para>
            Same as <see cref="F:Egelke.EHealth.Etee.Crypto.Level.LT_Level"/> for sealing, unsealing will check the timestamp chain is still valid (timemarks check remains the same).
            </para>
            <para>
            This means that the origin of the message becomes unsure at one point.  This can be avoided by adding additional timestamps, but that isn't 
            supported (yet) by this library.
            </para>
            </remarks>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.CertificateSecurityInformation">
            <summary>
            Security information of certificates.
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1">
            <summary>
            Base class for security violation data.
            </summary>
            <typeparam name="TViolation">The enum of possible violations</typeparam>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.ToString">
            <summary>
            Detailed printout of the object.
            </summary>
            <returns>String representation of the instance</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.ValidationStatus">
            <summary>
            Indicates if the content can be trusted.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.TrustStatus">
            <summary>
            Indicates if the sender can be confirmed.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.CertificateSecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.CertificateSecurityInformation.Certificate">
            <summary>
            The certificate on which the checks where executed.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.CertificateSecurityInformation.IssuerInfo">
            <summary>
            The security information of the issuer.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.CertificateSecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation"/>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory">
            <summary>
            <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer"/> factory class for sealed message receivers/readers.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory.Create(System.Nullable{Egelke.EHealth.Etee.Crypto.Level},System.Security.Cryptography.X509Certificates.X509Certificate2Collection)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer"/> interface to unseal messages.
            </summary>
            <remarks>
            <para>
            Can be used to unseal messages of any type of level, but for T-levels only if a 
            time stamp authority is used and not a time marker authority.
            </para>
            <para>
            The provided decryption certificates aren't checked and should include expired certificates
            in order to unseal historical messages.  It may even include revoked certificates, this that
            doesn't mean the message that is sealed with it is invalid, just that it isn't confidential any more.
            </para>
            </remarks>
            <param name="encCerts">Own (eHealth issued) certificates with private key that can be used to decrypt, they must have an <strong>exportable</strong> private key</param>
            <param name="level">The required level of the sender signatures or <c>null</c> for only basic validation without revocation checks</param>
            <returns>Instance of the IDataUnsealer</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory.CreateFromTimemarkAuthority(Egelke.EHealth.Etee.Crypto.Level,Egelke.EHealth.Client.Pki.ITimemarkProvider,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer"/> interface to unseal messages that where obtained from a time-mark authority.
            </summary>
            <remarks>
            <para>
            Can be used to unseal messages of LT-Level and TLA-Level that where obtained from a time-mark authority.  This time-mark authority can
            be centrals stores like ehBox but can also be internal stores that are considered secure and don't allow messages to be altered in any way.
            </para>
            <para>
            The provided decryption certificates aren't checked and should include expired certificates
            in order to unseal historical messages.  It may even include revoked certificates, this that
            doesn't mean the message that is sealed with it is invalid, just that it isn't confidential any more.
            </para>
            <para>
            In case the message does contain a time-stamp, it will be used and the time-mark authority will be ignored.
            </para>
            </remarks>
            <param name="encCerts">Own (eHealth issued) certificates with private key that can be used to decrypt, they must have an <strong>exportable</strong> private key</param>
            <param name="level">The required level of the sender signatures, either T-Level, LT-Level or LTA-Level</param>
            <param name="timemarkauthority">The client of the time-mark authority</param>
            <returns>Instance of the IDataUnsealer for messages of the specified a time-mark authority</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer">
            <summary>
            Interface to read messages that are protected according to the eHealth End-To-End encryption.
            </summary>
            <remarks>
            <para>
            When you have a protected message you want to read, both identified (addressed messages) 
            and unknown (non-addressed messages), you should use an instance that implements this
            interface.
            </para>
            <para>
            The <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory"/> class should be used to get an instance that implements
            this interface.
            </para>
            <para>
            This interface assumes you have access to the required artififacts: your decryption certificate
            with private key or a KGSS generated key.  Retreiving the artifacts isn't part of this assembly, but this
            assembly is bundleled with source code that show how it can be done.
            </para>
            <para>
            The library does not occupy itself with the message itself.  It is always treated as an
            array of bytes.  If the message is text, xml or any other format, you and the receiving 
            parties are responsible for the correct encoding/decoding.  The library is also not 
            responsible of the transport of the messages.
            </para>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory"/>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.SecretKey"/>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Status.UnsealResult"/>
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer.Unseal(System.IO.Stream,Egelke.EHealth.Etee.Crypto.SecretKey)">
            <summary>
            Unseals a protected message of which you have the secret (but shared) key.
            </summary>
            <para>
            This method takes a sealed/protected message in the form of a stream and unseals it so it
            can be read.  It uses the key provided in the <paramref name="key"/> parameter for decryption,
            even if the instance contains a personal private key.  In other words, the secret key
            take precendence over the private key.
            </para>
            <param name="sealedData">The protected message that must be unsealed</param>
            <param name="key">The secret (but shared) key retrieved from the KGSS</param>
            <returns>
            <list type="bullet">
            <item>
            <description>The clear message as a temporary file stream that is deleted when the stream is closed</description>
            </item>
            <item>
            <description>The sender information, if known</description>
            </item>
            <item>
            <description>The detailed security information</description>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentNullException">When sealedData and/or key is null</exception>
            <exception cref="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when secret key does't correspond with message</exception>
            <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
            <example>
            Unseal an unaddressed message
            <code lang="cs">
            //Create a IAnonymousDataSealer instance
            IAnonymousDataSealer unsealer = DataUnsealerFactory.Create();
            
            //Read the key id send by the sender
            byte[] keyId = Utils.ReadFully("protectedForGroup.kid");
            //Get the key from the KGSS
            byte[] key = GetKeyFromKGSS(keyId);
            //Create a secrte key object
            SecretKey skey = new SecretKey(keyId, key);
            
            UnsealResult result;
            FileStream file = new FileStream("protectedForGroup.msg", FileMode.Open);
            using(file)
            {
                result = unsealer.Unseal(file, skey);
            }
            //Check if the content is in order
            if (result.SecurityInformation.ValidationStatus != ValidationStatus.Valid) throw new Exception(result.SecurityInformation.ToString());
            //Check if sender and receiver used valid and up to spec certificates
            if (result.SecurityInformation.TrustStatus != TrustStatus.Full) throw new Exception(result.SecurityInformation.ToString());
            //Check if the sender is allowed to send a message (application specific)
            VerifySender(result.Sender);
            //Use the message (application specific)
            ImportMessage(result.UnsealedData);
            </code>
            <code lang="vbnet">
            'Create a IAnonymousDataSealer instance
            Dim unsealer As IAnonymousDataUnsealer = DataUnsealerFactory.Create()
            
            'Read the key id send by the sender
            Dim keyId As Byte() = Utils.ReadFully("protectedForGroup.kid")
            'Get the key from the KGSS
            Dim key As Byte() = GetKeyFromKGSS(keyId)
            'Create a secrte key object
            Dim skey As New SecretKey(keyId, key)
            
            Dim result As UnsealResult
            Dim file As New FileStream("protectedForGroup.msg", FileMode.Open)
            Using file
                result = unsealer.Unseal(file, skey)
            End Using
            'Check if the content is in order
            If result.SecurityInformation.ValidationStatus &lt;&gt; ValidationStatus.Valid Then
                Throw New Exception(result.SecurityInformation.ToString())
            End If
            'Check if sender and receiver used valid and up to spec certificates
            If result.SecurityInformation.TrustStatus &lt;&gt; TrustStatus.Full Then
                Throw New Exception(result.SecurityInformation.ToString())
            End If
            'Check if the sender is allowed to send a message (application specific)
            VerifySender(result.Sender)
            'Use the message (application specific)
            ImportMessage(result.UnsealedData)
            </code>
            </example>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer.Unseal(System.IO.Stream)">
             <summary>
             Unseals a protected message addressed to you.
             </summary>
             <remarks>
             <para>
             This method takes a sealed/protected message in the form of a stream and unseals it so it
             can be read.  It uses the personal private key to decrypt, see <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.DataUnsealerFactory"/> 
             how this private key should be provided.
             </para>
             </remarks>
             <param name="sealedData">The protected message that must be unsealed</param>
             <returns>
             <list type="bullet">
             <item>
             <description>The clear message as a temporary file stream that is deleted when the stream is closed</description>
             </item>
             <item>
             <description>The sender information, if known</description>
             </item>
             <item>
             <description>The detailed security information</description>
             </item>
             </list>
             </returns>
             <exception cref="T:System.ArgumentNullException">When sealedData is null</exception>
             <exception cref="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException">When the protected message isn't an correctly constructed or when the message isn't intended for you</exception>
             <exception cref="T:System.InvalidOperationException">When the instance of the object does not have a private key</exception>
             <exception cref="T:System.NotSupportedException">When the message contains multiple signatures</exception>
             <example>
             Unseal an addressed message
             <code lang="cs">
             //Create a IDataSealer instance
             IDataUnsealer unsealer = DataUnsealerFactory.Create(SelfEnc, SelfAuth);
             
             UnsealResult result;
             FileStream file = new FileStream("protectedForMe.msg", FileMode.Open);
             using(file)
             {
                 result = unsealer.Unseal(file);
             }
             //Check if the content is in order
             if (result.SecurityInformation.ValidationStatus != ValidationStatus.Valid) throw new Exception(result.SecurityInformation.ToString());
             //Check if sender and receiver used valid and up to spec certificates
             if (result.SecurityInformation.TrustStatus != TrustStatus.Full) throw new Exception(result.SecurityInformation.ToString());
             //Check if the sender is allowed to send a message (application specific)
             VerifySender(result.Sender);
             //Use the message (application specific)
             ImportMessage(result.UnsealedData);
             </code>
             <code lang="vbnet">
             'Create a IDataSealer instance
             Dim unsealer As IDataUnsealer = DataUnsealerFactory.Create(Utils.SelfEnc, Utils.SelfAuth)
            
             Dim result As UnsealResult
             Dim file As New FileStream("protectedForMe.msg", FileMode.Open)
             Using file
                 result = unsealer.Unseal(file)
             End Using
             'Check if the content is in order
             If result.SecurityInformation.ValidationStatus &lt;&gt; ValidationStatus.Valid Then
                 Throw New Exception(result.SecurityInformation.ToString())
             End If
             'Check if sender and receiver used valid and up to spec certificates
             If result.SecurityInformation.TrustStatus &lt;&gt; TrustStatus.Full Then
                 Throw New Exception(result.SecurityInformation.ToString())
             End If
             'Check if the sender is allowed to send a message (application specific)
             VerifySender(result.Sender)
             'Use the message (application specific)
             ImportMessage(result.UnsealedData)
             </code>
             </example>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation">
            <summary>
            Security information of encrypted blocks, based for signed blocks.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.Subject">
            <summary>
            Information about the issuer/sender (signature) or recipient (decryption).
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation"/>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation">
            <summary>
            Security information of signed blocks
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation.ToString(System.Int32)">
            <summary>
            Used in the ToString method
            </summary>
            <param name="level">The identation level</param>
            <returns>The string representation of the object</returns>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation.SigningTime">
            <summary>
            The (UTC) time the message was sealed on.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation.SignatureValue">
            <summary>
            The value of the signature (for Time Marker Authority)
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation.Signer">
            <summary>
            The certificate of the signer.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.SignatureSecurityInformation.TimestampRenewalTime">
            <summary>
            The (UTC) time the timestamp should be renewed (if applicable).
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation">
            <summary>
            Information about the security checks while unsealing an message.
            </summary>
            <remarks>
            <para>
            Groups information about the outer signature, inner signature and
            encryption/decryption.  There are no specific checks/violations at 
            this level.
            </para>
            <para>
            For a detailed but still comprehensible representation of the instance,
            use the ToString method.  In general there is quite
            a lot of information, so a (tab aware) text viewer is advised.
            </para>
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.ToString(System.Int32)">
            <summary>
            Detail printout to incopreate in the parent printout.
            </summary>
            <param name="level">The number of parent</param>
            <returns>String representation of the instance</returns>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.OuterSignature">
            <summary>
            Security information about the outer signature.
            </summary>
            <value>
            Contains information if the encrypted messages was correctly
            signed an by who.
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.Encryption">
            <summary>
            Security information about the encryption/decryption.
            </summary>
            <value>
            Contains information if the encryption was done
            up to spec and the certificate that was used
            to decrypt.
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.InnerSignature">
            <summary>
            Security information about the inner signature.
            </summary>
            <value>
            Contains information if the was correctly signed
            and by who.
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.SecurityViolations">
            <summary>
            Detailed list of all the security violations for this object.
            </summary>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation"/>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.ITmaDataVerifier">
            <summary>
            Message verifier for time-mark authorities.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.ITmaDataVerifier.Verify(System.IO.Stream,System.DateTime,Egelke.EHealth.Etee.Crypto.Store.TimemarkKey@)">
            <summary>
            Verifies the provided message on the provided date-time and returns the time-mark key.
            </summary>
            <remarks>
            Has an output parameter that will provide the time-mark key.  As a time-mark authority
            you are supposed use this key for the audit trail used for time-marking.  It must also
            be possibel to lookup the time-mark of the message via this key.
            </remarks>
            <seealso cref="M:Egelke.EHealth.Etee.Crypto.Store.IDataVerifier.Verify(System.IO.Stream)"/>
            <param name="sealedData">The message to verify</param>
            <param name="date">The validate date of the message (normally reception date)</param>
            <param name="timemarkKey">The time-mark key to be linked to the message</param>
            <returns>The result and additional information about the authentication part of the message</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.IDataVerifier">
            <summary>
            Message verifier for non time-mark authority.
            </summary>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.IDataVerifier.Verify(System.IO.Stream)">
            <summary>
            Verifies the provided message.
            </summary>
            <remarks>
            <para>
            Verifies the authentication part of the message, it does not decrypt the message
            or verifies the signature (non-repudiation) part.  It does not require the 
            possession of any decryption key and keeps the confidiality of the content.
            </para>
            <para>
            The level of verification depends on the level specified during creation. When required
            by the level, the siging time is validated via the embedded time-stamp or the time-mark provided
            that is specified during creation.
            </para>
            </remarks>
            <param name="sealedData">The message to verify</param>
            <returns>The result and additional information about the authentication part of the message</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.UnsealResult">
            <summary>
            The unsealed data and additional info.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.UnsealedData">
            <summary>
            The unsealed/clear data.
            </summary>
            <value>
            <para>
            The unsealed data is never null, if any of the Unseal method of <see cref="T:Egelke.EHealth.Etee.Crypto.Receiver.IDataUnsealer"/> fail
            to extract the clear data an exception is thrown. <strong>Warning:</strong> the clear data is always
            provided, even if the security verification detected major violations.  Make sure you check
             <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SecurityInformation"/> is the data is valid and can be trusted or not.
            </para>
            <para>
            The property is always a stream, but can eighter be a MemoryStream or a Temporaly FileStream, depending
            on the Unseal method that was invoked.  The FileStream does clean up the temporaly file on closing.
            </para>
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SecurityInformation">
            <summary>
            The results of the security checks.
            </summary>
            <value>
            This propery must be used to check if the data of the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.UnsealedData"/> is
            valid and can be trusted is not.  You should not accept any messages that have a
            validation status different from <see cref="F:Egelke.EHealth.Etee.Crypto.Status.ValidationStatus.Valid"/> or a truststatus
            different from <see cref="F:Egelke.EHealth.Etee.Crypto.Status.TrustStatus.Full"/>.
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.AuthenticationCertificate">
            <summary>
            The sender of the message, i.e. the signer of the outer message.
            </summary>
            <value>
            <para>
            This provides information about the entity that sent the message, without vouching for the content.
            The information about the entity that vouches for the content can be found in <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SigningCertificate"/>
            In general these represent the same entity, but aren't nesesary the same certificate.
            </para>
            <para>
            The application is supposed to verify that the sender is actualy
            allowed, the libray only validate
            that the sender information can be used (=trusted) or not.  The definition 
            an validation against the list of allowed senders is out of scope
            for this library.
            </para>
            </value>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SigningCertificate">
            <summary>
            The issuer of the message, i.e. the signer of the inner message.
            </summary>
            <remarks>
            <para>
            This provides information about the entity that voiching for the content of the message message, without indicating who sent it.
            The information about the entity that send the message can be found in <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.AuthenticationCertificate"/>
            In general these represent the same entity, but aren't nesesary the same certificate.
            </para>
            </remarks>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SignatureValue">
            <summary>
            The value of the authentication (outer) signature.
            </summary>
            <remarks>
            This value is used for the time-mark authority.
            </remarks>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SealedOn">
            <summary>
            The time the message was sealed on.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Status.UnsealResult.SealValidUntil">
            <summary>
            The time until the current message can be validated.
            </summary>
            <remarks>
            This only applies to LTA-Level where an embedded time-stamp
            can only be trusted as long as it can be validated with
            absolute certainly.
            </remarks>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.ValidationStatus">
            <summary>
            Indicates if object is correct or not.
            </summary>
            <remarks>
            <para>
            The object depends on where this enum is used.  The object can be the message,
            an inner/outer signature, certificate, etk, ...
            </para>
            <para>
            Correct means that the object isn't altered by somebody other then the issuer
            and that is conforms to the eHealth requirements.
            </para>
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.ValidationStatus.Valid">
            <summary>
            <para>
            The object isn't altered and conforms to eHealth requirements.
            </para>
            <para>
            This result means you can use the object, but you still
            have to check if you can trust the issue, <see cref="T:Egelke.EHealth.Etee.Crypto.Status.TrustStatus"/>.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.ValidationStatus.Unsure">
            <summary>
            <para>
            It was impossible to execute all required checks at this time because some information wasn't available.
            </para>
            <para>
            You should not use this object.  Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.SecurityViolations"/> 
            property for the reason and try to fix it (e.g restore Internet
            access so the CRL file can be downloaded) and run the verification again on the same object.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.ValidationStatus.Invalid">
            <summary>
            <para>
            The checks detected a security violation.
            </para>
            <para>
            You may not use this object.  Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.SecurityViolations"/> 
            property for the reason and communicate it to the sender.  The sender should then re-create the object,
            this time according to the specs.
            </para>
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.TrustStatus">
            <summary>
            Indicates if the object comes from a trusted issuer or not.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.TrustStatus.Full">
            <summary>
            <para>
            The issuer is fully trusted.
            </para>
            <para>
            You should use the object, but only if you trust this specific issuer.  This value
            only indicates the issuer is who he claims to be, it does not guarantee that
            he is allowed to issue the object for you application.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.TrustStatus.Unsure">
            <summary>
            <para>
            The issuer is not trusted because some checks could not be executed.
            </para>
            <para>
            You should not accept this message, although it is very likely the sender is correct.  
            Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.SecurityViolations"/>  property for the reason.  
            If the reason is the sender, you may request the sender to fix it and resend the message. 
            If the reason is local, it is sufficient to fix it and redo the validation.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.TrustStatus.None">
             <summary>
             <para>
            The issuer is not trusted because some checks failed.
            </para>
            <para>
             You may not accept the message.  The sender information, if present, is probably not correct.
             </para>
             </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation">
            <summary>
            Detailed security information about an unsealed message.
            </summary>
            <remarks>
            <para>
            Indicates which parts of the unsealed message there are security issues:
            <list type="bullet">
            <item>
            <description>Sender, the person that sent and signed the message</description>
            </item>
            <item>
            <description>Data, the content (clear) of the message</description>
            </item>
            <item>
            <description>Recipient, the receiver for who the message is intended</description>
            </item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation.UntrustedSender">
            <summary>
            <para>
            Sender can't be trusted.
            </para>
            <para>
            The sender/issuer information that is in this message can't be trusted.
            Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.OuterSignature"/> or 
            <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.InnerSignature"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation.SenderTrustUnknown">
            <summary>
            <para>
            Sender trust is unknown.
            </para>
            <para>
            It is unsure if the sender/issuer information that is in this message can be trusted or not.
            The sender/issuer information that is in this message can't be trusted.
            Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.OuterSignature"/> or 
            <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.InnerSignature"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation.UntrustedRecipient">
            <summary>
            <para>
            Receiver can't be trusted.
            </para>
            <para>
            The receiver, that is you, can't be trusted.  This means an encryption/decryption
            certificate is used that is (no longer) valid.
            Check the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityInformation.Encryption"/> properties for
            more information.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation.InvalidData">
            <summary>
            <para>
            The data is invalid.
            </para>
            <para>
            The data validation failed, most likely this is due to the fact that the
            data is altered, but it could also mean the sender or receiver information
            is changed.  The <see cref="M:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.#ctor"/> and 
            <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityResult`1.TrustStatus"/> properties reflect the situation
            where the data is altered, but it might as well be the sender and or receiver
            that are changed.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.UnsealSecurityViolation.DataValidityUnkown">
            <summary>
            It is unknown if the data is valid or not, most likely because of missing signature information.
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation">
            <summary>
            Detailed security information about a security operation, either signature or encryption.
            </summary>
            <remarks>
            This library does treat signing and encryption in the say way for certain extend.  Both
            have a certificate, for signing this is the sender for encryption this is the receiver, which
            is called "Subject".  The checks on the subject are exactly the same for signing and encryption.
            The checks for the signature itself and the decryption are different, therefore both have
            specific violations.
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotAllowedEncryptionAlgorithm">
            <summary>
            <para>
            The content is encrypted with an unaccepted algorithm (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symmetric key
            is used to encrypt the content and only the symmetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only the most advanced encryption
            algorithms are allowed.  This violation occurs when a
            less advanced algorithm is used for the encryption of content
            by the symmetric key.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotAllowedKeyEncryptionAlgorithm">
            <summary>
            <para>
            The key is encrypted with an unaccepted algorithm (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symmetric key
            is used to encrypt the content and only the symmetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only the most advanced encryption
            algorithms are allowed.  This violation occurs when a
            less advanced algorithm is used for the encryption of the
            symmetric key by the public key of the receiver.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotAllowedEncryptionKeySize">
            <summary>
            <para>
            The key is encrypted with an unacceptable key size (encryption).
            </para>
            <para>
            The content of an sealed message is never encrypted directly with
            the public key of the receiver.  Instaid a (faster) symmetric key
            is used to encrypt the content and only the symmetric key itself
            is sealed with the public key of the receiver(s).
            </para>
            <para>
            For security reasons, only keys of a certain size are allowed.  
            This violation occurs when a the public key of the receiver is
            smaller then the minimum size.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotSigned">
            <summary>
            <para>
            There was no signature present (signing).
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotFoundSigner">
            <summary>
            <para>
            The signer info wasn't present (signing).
            </para>
            <para>
            Normally a sealed message contains the information about the signer,
            if this information is missing it is impossible to verify the
            signature and this violation is raised.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotSignatureValid">
            <summary>
            <para>
            The signature was invalid (signing).
            </para>
            <para>
            When this violation is raised, either the data is altered
            or the issuer information is substituted.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotAllowedSignatureDigestAlgorithm">
            <summary>
            <para>
            The digest algorithm for signing isn't allowed (signing).
            </para>
            <para>
            In most cases a signature consist of an encrypted
            digest of the content.  Therefore a signature algorithm
            consists of a digest algorithm and a encryption algorithm.
            The encryption algorithm of the signature is not related
            to the encryption algorithm of the encryption.
            </para>
            <para>
            For security reasons only the most advanced algorithms are
            allowed.  This violation occurs when the digest algorithm of the 
            signature is less advanced then required.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.NotAllowedSignatureEncryptionAlgorithm">
            <summary>
            <para>
            The encryption algorithm for signing isn't allowed (signing).
            </para>
            <para>
            In most cases a signature consist of an encrypted
            digest of the content.  Therefore a signature algorithm
            consists of a digest algorithm and a encryption algorithm.
            The encryption algorithm of the signature is not related
            to the encryption algorithm of the encryption.
            </para>
            <para>
            For security reasons only the most advanced algorithms are
            allowed.  This violation occurs when the encryption algorithm of the 
            signature is less advanced then required.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.UntrustedSubject">
            <summary>
            <para>
            The subject information should not be trusted (common).
            </para>
            <para>
            The issuer (signing) or receiver (encryption) information failed to
            validate. See the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.Subject"/> property
            for more information.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.SubjectTrustUnknown">
            <summary>
            <para>
            The subject information should not be validated (common).
            </para>
            <para>
            It was impossible to validate the issuer (signing) or receiver (encryption) information. 
            See the <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.Subject"/> property
            for more information.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.SubjectDoesNotMachEnvelopingSubject">
            <summary>
            The inner subject isn't the same as the outer subject.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.SealingTimeInvalid">
            <summary>
            <para>
            The time indicated by the message at which it is sealed is not valid.
            </para>
            <para>
            The message includes a time-stamp which which contains a time that doesn't
            correspond with the sealing time indicated by the message.  This voids the
            trust because the sender is validated on the sealing time that is (incorrectly)
            indicated.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.SecurityViolation.InvalidTimestamp">
            <summary>
            The included time-stamp was invalid or could not be trusted.
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation">
            <summary>
            Detailed security information about a certificate (=Subject, Receiver, Issuer, Sender,...).
            </summary>
            <remarks>
            <para>
            Certificate are validated on a number of point.  Each of this validation can result in
            its own security violation.  See the different member for more information.
            </para>
            <para>
            Each certificate has an issuer.  Security violation of these issues also cause a security
            violation on the certificate itself.
            </para>
            </remarks>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.UntrustedIssuer">
            <summary>
            The issue was invalid. See <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.Subject"/> property for more information.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.IssuerTrustUnknown">
            <summary>
            The issuer validation was impossible. See <see cref="P:Egelke.EHealth.Etee.Crypto.Status.SecurityInformation.Subject"/> property for more information.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NotValidKeyType">
            <summary>
            <para>
            The public key in the certificate isn't supported, currently on RSA and DSA are. 
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NotValidKeySize">
            <summary>
            <para>
            The size of the key for this certificate is less then the required minimum.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NotTimeValid">
            <summary>
            <para>
            The certificate is not yet or no longer valid at the time of use.
            </para>
            <para>
            For encryption the time is always validated with the current time since
            the validation always occurs together with the decryption.  For signing certificates
            the signing time is used for validation, is the signing time isn't available
            the current time is used.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.Revoked">
            <summary>
            <para>
            The certificate is revoked according to the windows revocation mechanism.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NotSignatureValid">
            <summary>
            <para>
            The signature of by certificate by it issuer isn't valid.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NotValidForUsage">
            <summary>
            <para>
            The certificate is incorrectly used.
            </para>
            <para>
            This can be either a signing certificate that is used
            for encryption or visa versa.  It can also be that a non
            CA certificate is used to issue a certificate.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.UntrustedRoot">
            <summary>
            <para>
            The root certificate could not be found in the trusted CA certificate store of you machine.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.RevocationStatusUnknown">
            <summary>
            <para>
            The revocation status of the certificate could not be determined.
            </para>
            <para>
            When the certificate contains revocation information windows recognizes
            but windows can't retrieve it, this violation is raised.  By default windows
            only supports CRLs.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.Cyclic">
            <summary>
            <para>
            The certificate chain is cyclic.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.InvalidExtension">
            <summary>
            The certificate contains an invalid extension.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.InvalidPolicyConstraints">
            <summary>
            The certificate violates a policy constraint.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.InvalidBasicConstraints">
            <summary>
            the certificate violates a basic constraint.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.InvalidNameConstraints">
            <summary>
            The certificate violates a name constraint.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.HasNotSupportedNameConstraint">
            <summary>
            The certificate contains a name constraint that can't be validated by windows.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.HasNotDefinedNameConstraint">
            <summary>
            The certificates violates a name constraint because its name wasn't defined.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.HasNotPermittedNameConstraint">
            <summary>
            The certificates violates a name constraint because its name is explicitly not permitted.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.HasExcludedNameConstraint">
            <summary>
            The certificates violates a name constraint because its name is excluded.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.OfflineRevocation">
            <summary>
            <para>
            The revocation information used was cached.
            </para>
            <para>
            CRLs, which are used for revocation, have a certain validity period a can
            therefore be cached.  The "violation" only indicates a cached version is used,
            this does not mean the certificate is invalid.
            </para>
            <para>
            If you application does not allow off-line revocation, you must explicitly 
            check the validation result.
            </para>
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.NoIssuanceChainPolicy">
            <summary>
            Specifies that there is no certificate policy extension in the certificate. This error would occur if a group policy has specified that all certificates must have a certificate policy.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.CtlNotSignatureValid">
            <summary>
            Specifies that the CRL or OCSP has an invalid signature.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.CtlNotTimeValid">
            <summary>
            Specifies that the CRL or OCSP is of the wrong time.
            </summary>
        </member>
        <member name="F:Egelke.EHealth.Etee.Crypto.Status.CertSecurityViolation.CtlNotValidForUsage">
            <summary>
            Specifies that the CRL or OCSP is invalid.
            </summary>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.EncryptionToken">
            <summary>
            Represents an ETK.
            </summary>
            <remarks>
            <para>
            This class represents an ETK retrieved from the ETK-Depot.  It can be used to seal messages so it can only be viewed by the party
            that owns the ETK and therefore has the private key corresponding to this.  It is possible, and even advised, to cache the ETK for
            parties you will probably require in the future.
            </para>
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.#ctor(System.String)">
            <summary>
            Constructor for the string representation of the ETK. 
            </summary>
            <remarks>
            <para>
            The xml representation of the "GetEtkResponse" of the ETK-Depot web service
            contains an element "ETK" of which is content can be provided to this
            constructor.  Normally you will not have access to the xml representation,
            so it is unlikely you will need this constructor for this reason.
            </para>
            <para>
            If you use a cache that can't handle binary data, use this constructor
            to use an instance from cache.
            </para>
            </remarks>
            <param name="data">Base64 encoded representation of the ETK</param>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.#ctor(System.Byte[])">
            <summary>
            Constructor for the binary representation of the ETK.
            </summary>
            <remarks>
            <para>
            The binary representation of the "GetEtkResponse" of the ETK-Depot web service
            contains an byte array item that can be provided to this constructor.
            </para>
            <para>
            If you use a cache that can handle binary data, use this constructor
            to use an instance from cache.
            </para>
            </remarks>
            <param name="data">raw ETK</param>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.GetEncoded">
            <summary>
            Gets the byte representation of the ETK.
            </summary>
            <returns>Binary form of the ETK, should be saved in a cache</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.GetEncodedAsString">
            <summary>
            Gets the string representation of the ETK.
            </summary>
            <returns>String form of the ETK, should be saved in a cache</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.Verify">
            <summary>
            Verifies if the ETK contains a token that is still valid and can be trusted.
            </summary>
            <remarks>
            Does check the revocation information of the certificates used to issue the
            certificate.
            </remarks>
            <seealso cref="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.Verify(System.Boolean)"/>
            <returns>Detailed information about the encryption certificate status</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.EncryptionToken.Verify(System.Boolean)">
            <summary>
            Verifies if the ETK contains a token that is still valid and can be trusted.
            </summary>
            <remarks>
            <para>
            This method checks if the certificate in the ETK is issued by a trusted party.  Trust means
            the root certificate is trusted by the computer it is running on and all
            validation checks, including revocation, are successful.  Root
            certificates are trusted by the computer if present in the 
            <see cref="F:System.Security.Cryptography.X509Certificates.StoreName.Root"/> store.
            </para>
            <para>
            This method no longer validates the signer of the ETK token due lack of signing time in the ETK.
            The encryption certificate inside the ETK is still completely verified, this means there isn't a reduction in
            security compared to the previous implementation.
            </para>
            </remarks>
            <param name="checkRevocation">Checks if the certificates that issued the encryption cert aren't revoked</param>
            <returns>Detailed information about the encryption certificate status</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer">
            <summary>
            Interface to protect messages according to the eHealth End-To-End encryption.
            </summary>
            <remarks>
            <para>
            When you have a message that you want to protect and send to one or more recipients, 
            both identified (addressed messages) and unknown (non-addressed messages), you should 
            use an instance that implements this interface.
            </para>
            <para>
            The <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory"/> class should be used to get an instance that implements
            this interface.
            </para>
            <para>
            This interface assumes you have access to the required artififacts: the receivers ETK 
            or a KGSS generated key.  Retreiving the artifacts isn't part of this assembly, but this
            assembly is bundleled with source code that show how it can be done.
            </para>
            <para>
            The library does not occupy itself with the message itself.  It is always treated as an
            array of bytes.  If the message is text, xml or any other format, you and the receiving 
            parties are responsible for the correct encoding/decoding.  The library is also not 
            responsible of the transport of the messages.
            </para>
            </remarks>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory"/>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.EncryptionToken"/>
            <seealso cref="T:Egelke.EHealth.Etee.Crypto.SecretKey"/>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer.Seal(System.IO.Stream,Egelke.EHealth.Etee.Crypto.EncryptionToken[])">
            <summary>
            Seals a message for one or more known recipients via eHealth ETK's.
            </summary>
            <remarks>
            <para>
            The message is signed, encrypted and signed again for maximum security.  The message also contains the
            authentication and signing certificate provided in the factory so the recipient can verify the origin.  
            The message also contains the following info depending on the level of which the instance was created:
            <list type="definition">
            <item>
            <term>B-Level</term>
            <description>No revocation info or time-stamp is added, no time-mark is required</description>
            </item>
            <item>
            <term>T-Level</term>
            <description>No revocation info is added, but a time-stamp is added or a time-mark is required</description>
            </item>
            <item>
            <term>LT-Level</term>
            <description>Revocation info is added and a time-stamp is added or a time-mark is required</description>
            </item>
            <item>
            <term>LTA-Level</term>
            <description>For sealing this is the same as LT-Level</description>
            </item>
            </list>
            </para>
            <para>
            In case size of a message exteeds <see cref="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.InMemorySize"/> temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="tokens">ETK tokens, only the owners of this tokens will be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for several known recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(eidAuth, eidSign, Level.B_Level);
            
            //Read the etk of a specific reciever
            EncryptionToken receiver1 = new EncryptionToken(Utils.ReadFully("other1.etk"));
            Utils.Check(receiver1.Verify()); //verify if it is (still) correct
            
            //Read the etk of another specific reciever
            EncryptionToken receiver2 = new EncryptionToken(Utils.ReadFully("other2.etk"));
            Utils.Check(receiver2.Verify()); //verify if it is (still) correct
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(file, receiver1, receiver2);
            }
            </code>
            </example>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer.Seal(System.IO.Stream,System.Security.Cryptography.X509Certificates.X509Certificate2[])">
            <summary>
            Seals a message for one or more known recipients via standard certificates.
            </summary>
            <remarks>
            This method can be used with any encryption certificates, including certificates that aren't issued by eHealth.
            This should not be used in an eHealth environement!
            </remarks>
            <seealso cref="M:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer.Seal(System.IO.Stream,Egelke.EHealth.Etee.Crypto.EncryptionToken[])"/>
            <param name="unsealed">The clear message that must be protected</param>
            <param name="certificates">The encryptiion certificates of the known recipients, without private key</param>
            <returns>The sealed message, this should be transported to the receivers.</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer.Seal(System.IO.Stream,Egelke.EHealth.Etee.Crypto.SecretKey,Egelke.EHealth.Etee.Crypto.EncryptionToken[])">
            <summary>
            Seals a message for unknown recipients and zero, one or more known recipients the same time via eHealth SecretKey and eHealth ETK's
            </summary>
            <remarks>
            <para>
            The message is signed, encrypted and signed again for maximum security.  The message also contains the
            authentication and signing certificate provided in the factory so the recipient can verify the origin.  
            The message also contains the following info depending on the level of which the instance was created:
            <list type="definition">
            <item>
            <term>B-Level</term>
            <description>No revocation info or time-stamp is added, no time-mark is required</description>
            </item>
            <item>
            <term>T-Level</term>
            <description>No revocation info is added, but a time-stamp is added or a time-mark is required</description>
            </item>
            <item>
            <term>LT-Level</term>
            <description>Revocation info is added and a time-stamp is added or a time-mark is required</description>
            </item>
            <item>
            <term>LTA-Level</term>
            <description>For sealing this is the same as LT-Level</description>
            </item>
            </list>
            </para>
            <para>
            This method takes a clear message in the form of a byte array and seals it so it
            can only be read by the recipients that that are specified or have access to the 
            same shared key.  This shared key should be retrieved from KGSS, the specified recipients
            can be retrieved from the ETK-Depot.
            </para>
            <para>
            In case size of a message exteeds <see cref="P:Egelke.EHealth.Etee.Crypto.Configuration.Settings.InMemorySize"/> temporary files are used.  It uses the standard temporary
            file directory of you machine for this.  Except for catastrofical failures, these temorary files
            are removed when no longer needed.  It is important that you have sufficient storage in your temporaly
            path, about 3 times the size of the input is needed.
            </para>
            </remarks>
            <param name="tokens">ETK tokens, the owners of this tokens will also be able to read the message</param>
            <param name="unsealed">The clear message that must be protected</param>
            <param name="key">KGSS shared but secret key, parties that have access to the same key can also read the messages</param>
            <returns>
            <para>
            The sealed message, this should be transported to the receivers.
            </para>
            <para>
            The stream that is returned is a FileStream to a file in the temporary folder of your machine.  The
            file is automaticly deleted when you dispose of the stream instance.
            </para>
            </returns>
            <seealso cref="M:System.IO.Path.GetTempFileName"/>
            <example>
            Sealing a message for both known and unknown recipient.
            <code lang="cs">
            //Create a IDataSealer instance, selfAuth is the eHealth authentication certificate of the user
            IDataSealer sealer = DataSealerFactory.Create(eidAuth, eidSign, Level.B_Level);
            
            //Create a secret key, keyId and Key are retreived from KGSS
            byte[] keyId;
            byte[] key = Utils.GetNewSecretKey(out keyId);
            SecretKey skey = new SecretKey(keyId, key);
            
            //Read the etk of a specific reciever
            EncryptionToken receiver1 = new EncryptionToken(Utils.ReadFully("other1.etk"));
            Utils.Check(receiver1.Verify()); //verify if it is (still) correct
            
            //Read the etk of another specific reciever
            EncryptionToken receiver2 = new EncryptionToken(Utils.ReadFully("other2.etk"));
            Utils.Check(receiver2.Verify()); //verify if it is (still) correct
            
            //Seal as stream
            Stream output;
            FileStream file = new FileStream("text.txt", FileMode.Open);
            using (file)
            {
                output = sealer.Seal(file, skey, receiver1, receiver2););
            }
            </code>
            </example>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory">
            <summary>
            <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> factory class for sealed message creators/senders.
            </summary>
            <remarks>
            This instance is specific for a sender, so if your program supports multiple senders it will need multiple instance.
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory.Create(Egelke.EHealth.Etee.Crypto.Level,System.TimeSpan)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for B-Level only.
            </summary>
            <remarks>
            <para>
            Each instances has an authentication and optionally a signing certificate.  Which can either be eID or eHealth certificates.
            In case of eHealth certificates, only the authentication certificate must be provided, it also be used as signing certificate.
            In case of eID certificates, both the authentication and signing certificate of the same person should be provided, the PIN will
            only be requested twice because of a windows limitation.
            </para>
            <para>
            eHealth certificate can only be loaded from the standard windows certificate store, the eHealth provided .p12 must
            be imported into the windows certificate store with <strong>exportable</strong> key.  It isn't possible to use the eHealth .p12 directly, because
            <see cref="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)"/>
            only supports files with one private key, the standard eHealth .p12 files have two.  For compatibility with the .Net Xades
            library, the eHealth .p12 library should be imported via the <c>EHealthP12</c>-class of the eH-I library.
            </para>
            </remarks>
            <param name="authentication">The eID Authentication certificate to use for proving the origin of the message.</param>
            <param name="signature">The eID Signature certificate to protect the content of the message</param>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <returns>Instance of the IDataSealer that can be used to protect messages in name of the provided sender (i.e. authentication and signature certificate)</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory.Create(Egelke.EHealth.Etee.Crypto.Level,Egelke.EHealth.Client.Pki.ITimestampProvider,System.TimeSpan)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for all levels except for B-Level.
            </summary>
            <remarks>
            Uses a time-stamp authority to indicate the time when the message was created. See the eH-I TSA module for possible implementation of existing authorities.
            See the message definition for which authority must be used if any, the eH-I TSA module provides clients for both eHealth and Fedict but can be extended to any
            authority that returns compliant time-stamp-tokens.
            </remarks>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <param name="timestampProvider">The client of the time-stamp authority</param>
            <seealso cref="!:Create(X509Certificate2, X509Certificate2, Level)"/>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Sender.EidDataSealerFactory.CreateForTimemarkAuthority(Egelke.EHealth.Etee.Crypto.Level,System.TimeSpan)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Sender.IDataSealer"/> interface suitable for all levels except for B-Level.
            </summary>
            <remarks>
            The returned data sealer assumes that the messages will be send via a time-mark authority and will therefore not attempt to add a time-stamp.
            The data sealer has not direct dependency to this time-mark authority, it is the caller that must send it himself.
            </remarks>
            <param name="authentication">The eID Authentication certificate to use for proving the origin of the message.</param>
            <param name="signature">The eID Signature certificate to protect the content of the message</param>
            <param name="level">The level of the sealing, only B-Level is allowed (parameter present for awareness)</param>
            <seealso cref="!:Create(X509Certificate2, X509Certificate2, Level)"/>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException">
            <summary>
            Exception indication the protected message can't be processed.
            </summary>
            <remarks>
            When a protected message is not compliant in a way that it is impossible to
            process it, an InvalidMessageException is thrown.
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.InvalidMessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.InvalidMessageException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.SecretKey">
            <summary>
            Represents an symmetric secret key or Key Encryption Key.
            </summary>
            <remarks>
            <para>
            This class represents a secret, but shared, key from the KGSS.  It can be used to seal messages so it can only be viewed by the 
            that the KGSS allows to retrieve the same key.  It isn't advised to use the same key for more then one message.  
            </para>
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.SecretKey.#ctor(System.String,System.String)">
            <summary>
            Constructor for the string representation of the KEK.
            </summary>
            <remarks>
            <para>
            The xml representation of the "GetNewKeyResponseContent" contains both the id as the key
            that can be provided to this constructor.  The xml representation "GetKeyResponseContent"
            only contains the key param for this constructor, the id param should be the same as
            in the xml representation of "GetKeyRequestContent".
            </para>
            </remarks>
            <param name="id">The ID of the KEK.  Senders get it from the KGSS web service, receivers 
            get it directly from the sender in an application specific way.</param>
            <param name="key">The KEK itself, always retrieved from the KGSS web service</param>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.SecretKey.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Constructor for the binary representation of the KEK.
            </summary>
                    /// <remarks>
            <para>
            The binary representation of the "GetNewKeyResponseContent" contains both the id as the key
            that can be provided to this constructor.  The binary representation "GetKeyResponseContent"
            only contains the key param for this constructor, the id param should be the same as
            in the binary representation of "GetKeyRequestContent".
            </para>
            </remarks>
            <param name="id">The ID of the KEK.  Senders get it from the KGSS web service, receivers 
            get it directly from the sender in an application specific way</param>
            <param name="key">The KEK itself, always retrieved from the KGSS web service</param>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.SecretKey.Id">
            <summary>
            The binary form of the KEK id.
            </summary>
            <remarks>
            <para>
            This is the only part of the KEK that the application itself must transmit to the receiver,
            together with the message itself.  This is public information, so there is no need to seal it
            for transport.
            </para>
            <para>
            Use this representation of the KEK id if the transport support binary information.
            </para>
            </remarks>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.SecretKey.IdString">
            <summary>
            The string form of the KEK id.
            </summary>
            <remarks>
            <para>
            This is the only part of the KEK that the application itself must transmit to the receiver,
            together with the message itself.  This is public information, so there is no need to seal it
            for transport.
            </para>
            <para>
            Use this representation of the KEK id if the transport only support text information.
            </para>
            </remarks>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.DataVerifierFactory">
            <summary>
            <see cref="T:Egelke.EHealth.Etee.Crypto.Store.IDataVerifier"/> factory class for sealed message stores.
            </summary>
            <remarks>
            Intended for sealed messages stores that will verify sealed messages but not necessary unseal them.
            Often these message store are time-mark authorities, but this isn't a required.
            </remarks>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataVerifierFactory.Create(System.Nullable{Egelke.EHealth.Etee.Crypto.Level})">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Store.IDataVerifier"/> interface to verify messages.
            </summary>
            <remarks>
            <para>
            Verifies the authentication part of the message, not the signer (non-repudiation) of
            the message.  It does not decrypt the message, so the content remains hidden and it
            does not require the possession of any key.
            </para>
            <para>
            Can be used to verify all types of messages, including those with time information (T, LT and LTA-Level) in
            case a time-stamp authority is used and not a time-mark authority.
            </para>
            </remarks>
            <param name="level">The level to which a message must conform to, <c>null</c> meaning no revocation check must be done</param>
            <returns>The completer of the required level that will verify the message, using the embedded timestamps if needed</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataVerifierFactory.CreateAsTimemarkAuthority(Egelke.EHealth.Etee.Crypto.Level)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Store.ITmaDataVerifier"/> interface to verify messages as time-mark authority.
            </summary>
            <remarks>
            For usage by a time mark authority, allows you to provide the known time-mark before the time-mark key is known.
            </remarks>
            <seealso cref="M:Egelke.EHealth.Etee.Crypto.Store.DataVerifierFactory.Create(System.Nullable{Egelke.EHealth.Etee.Crypto.Level})"/>
            <param name="level">The level to which a message must conform to: T, LT or LTA level</param>
            <returns>The completer of the required level that will verify the message according to the provided date time</returns>
        </member>
        <member name="M:Egelke.EHealth.Etee.Crypto.Store.DataVerifierFactory.CreateFromTimemarkAuthority(Egelke.EHealth.Etee.Crypto.Level,Egelke.EHealth.Client.Pki.ITimemarkProvider)">
            <summary>
            Creates an instance of the <see cref="T:Egelke.EHealth.Etee.Crypto.Store.ITmaDataVerifier"/> interface to verify messages retrieved from a time-mark authority.
            </summary>
            <remarks>
            For usage with messages that come from a time-mark authority (e.g. ehBox).  In case the message contains an embedded time-stamp,
            it takes precedence and the time mark authority isn't used.
            </remarks>
            <param name="level">The level to which a message must conform to: T, LT or LTA level</param>
            <param name="timemarkAuthority">The client of the time-mark authority used to retrieve the time-mark during verification</param>
            <returns>The completer of the required level that will verify the message with the provided time-mark authority</returns>
        </member>
        <member name="T:Egelke.EHealth.Etee.Crypto.Store.TimemarkKey">
            <summary>
            The key to retrieve a time-mark by.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Store.TimemarkKey.Signer">
            <summary>
            The signer of the message.
            </summary>
            <remarks>
            The entire certificate is provided so the time-mark authority can
            decide itself how to identify the signer, e.g. thumpprint, 
            serial+issuer, ...
            </remarks>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Store.TimemarkKey.SigningTime">
            <summary>
            The signing time indicated by the message.
            </summary>
        </member>
        <member name="P:Egelke.EHealth.Etee.Crypto.Store.TimemarkKey.SignatureValue">
            <summary>
            The signature value of the message, to uniquely link it to the message.
            </summary>
        </member>
    </members>
</doc>
